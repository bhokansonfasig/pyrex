"""
Module containing customized detector geometry classes for ARA.

Designed to be flexible such that stations can be built up from any string
types and the detector grid can be made up of stations or strings.

"""

import numpy as np
from pyrex.signals import Signal
from pyrex.detector import Detector
from pyrex.ice_model import IceModel
from .antenna import HpolAntenna, VpolAntenna


def convert_hex_coords(hex_coords, unit=1):
    """
    Convert from hexagonal coordinates to Cartesian.

    Parameters
    ----------
    hex_coords : array_like
        Array with two elements representing the hexagonal coordinate.
    unit : float, optional
        Optional unit used to multiply the Cartesian coordinates.

    Returns
    -------
    x : float
        Cartesian x-position with the unit correction.
    y : float
        Cartesian y-position with the unit correction.

    Notes
    -----
    Hexagonal coordinate system defined along non-perpendicular axes where the
    first axis is 30 degrees from the Cartesian x-axis and the second axis is
    parallel to the Cartesian y-axis. The conversion equations are therefore
    x=h_0-h_1/2 and y=h_1*sqrt(3)/2.

    """
    x = (hex_coords[0] - hex_coords[1]/2) * unit
    y = (hex_coords[1] * np.sqrt(3)/2) * unit
    return (x, y)



class ARAString(Detector):
    """
    String of ARA Hpol and Vpol antennas.

    Sets the positions of antennas on string based on the parameters. Once the
    antennas have been built with `build_antennas`, the object can be
    directly iterated over to iterate over the antennas (as if the object were
    just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the string.
    y : float
        Cartesian y-position (m) of the string.
    antennas_per_string : float, optional
        Total number of antennas to be placed on the string.
    antenna_separation : float or list of float, optional
        The vertical separation (m) of antennas on the string. If ``float``,
        all antennas are separated by the same constant value. If ``list``,
        the separations in the list are the separations of neighboring
        antennas starting from the lowest up to the highest.
    lowest_antenna : float, optional
        The Cartesian z-position (m) of the lowest antenna on the string.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.ara.HpolAntenna : ARA Hpol (“quad-slot”) antenna system with
                                   front-end processing.
    pyrex.custom.ara.VpolAntenna : ARA Vpol (“bicone” or “birdcage”) antenna
                                   system with front-end processing.

    Notes
    -----
    This class is designed to be the lowest subset level of a detector. It can
    (and should) be used for the subsets of some other ``Detector`` subclass
    to build up a full detector. Then when its "parent" is iterated, the
    instances of this class will be iterated as though they were all part of
    one flat list.

    """
    def set_positions(self, x, y, antennas_per_string=4,
                      antenna_separation=10, lowest_antenna=-200):
        """
        Generates antenna positions along the string.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the string.
        y : float
            Cartesian y-position (m) of the string.
        antennas_per_string : float, optional
            Total number of antennas to be placed on the string.
        antenna_separation : float or list of float, optional
            The vertical separation (m) of antennas on the string. If ``float``,
            all antennas are separated by the same constant value. If ``list``,
            the separations in the list are the separations of neighboring
            antennas starting from the lowest up to the highest.
        lowest_antenna : float, optional
            The Cartesian z-position (m) of the lowest antenna on the string.

        """
        if hasattr(antenna_separation, '__len__'):
            if len(antenna_separation)!=antennas_per_string-1:
                raise ValueError("Bad number of antenna separations given")
            def z_sep(i):
                """Return the z-separation between antennas `i` and `i`+1."""
                return antenna_separation[i-1]
        else:
            def z_sep(i):
                """Return the z-separation between antennas `i` and `i`+1."""
                return antenna_separation
        for i in range(antennas_per_string):
            z = lowest_antenna if i==0 else z+z_sep(i)
            self.antenna_positions.append((x, y, z))

    def build_antennas(self, power_threshold, amplification=1,
                       naming_scheme=lambda i, ant: ant.name[:4]+"_"+str(i),
                       class_scheme=lambda i: HpolAntenna if i%2 else VpolAntenna,
                       noisy=True, unique_noise_waveforms=10):
        """
        Creates antenna objects at the set antenna positions.

        The antennas built are ARA Hpol or Vpol antennas, as determined by the
        `class_scheme`.

        Parameters
        ----------
        power_threshold : float
            Power threshold for antenna trigger conditions.
        amplification : float, optional
            Amplification to be applied to antenna signals.
        naming_scheme : function, optional
            Function used to assign the ``name`` parameter for each antenna.
            Takes the index of the antenna on the string and the antenna
            object itself as parameters and should return a string for the
            antenna's name. By default names antennas "Hpol_X" or "Vpol_X"
            where "X" is the antenna's index.
        class_scheme : function, optional
            Function used to decide the class to use for each antenna. Takes
            the index of the antenna on the string as a parameter and should
            return which class to use to create the antenna object. By default
            alternates VpolAntenna and HpolAntenna going up the string.
        noisy : boolean, optional
            Whether or not the antenna should add noise to incoming signals.
        unique_noise_waveforms : int, optional
            The number of expected noise waveforms needed for each received
            signal to have its own noise (per antenna).

        """
        self.subsets = []
        for i, pos in enumerate(self.antenna_positions):
            AntennaClass = class_scheme(i)
            self.subsets.append(
                AntennaClass(name=AntennaClass.__name__, position=pos,
                             power_threshold=power_threshold,
                             amplification=amplification,
                             noisy=noisy,
                             unique_noise_waveforms=unique_noise_waveforms)
            )
        for i, ant in enumerate(self.subsets):
            ant.name = str(naming_scheme(i, ant))

    def triggered(self, antenna_requirement=1, require_mc_truth=False):
        """
        Check if the string is triggered based on its current state.

        String is triggered if the number of antennas that have been hit
        (according to ``is_hit``) is greater than or equal to the
        `antenna_requirement`.

        Parameters
        ----------
        antenna_requirement : float, optional
            The number of antennas which must be hit for the string to trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the string is triggered in its current state.

        See Also
        --------
        pyrex.custom.ara.HpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.
        pyrex.custom.ara.VpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.

        """
        if require_mc_truth:
            antennas_hit = sum(1 for ant in self if ant.is_hit_mc_truth)
        else:
            antennas_hit = sum(1 for ant in self if ant.is_hit)
        return antennas_hit>=antenna_requirement



class PhasedArrayString(Detector):
    """
    Phased string of closely-packed antennas.

    Sets the positions of antennas on string based on the parameters. Once the
    antennas have been built with `build_antennas`, the object can be
    directly iterated over to iterate over the antennas (as if the object were
    just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the string.
    y : float
        Cartesian y-position (m) of the string.
    antennas_per_string : float, optional
        Total number of antennas to be placed on the string.
    antenna_separation : float or list of float, optional
        The vertical separation (m) of antennas on the string. If ``float``,
        all antennas are separated by the same constant value. If ``list``,
        the separations in the list are the separations of neighboring
        antennas starting from the lowest up to the highest.
    lowest_antenna : float, optional
        The Cartesian z-position (m) of the lowest antenna on the string.
    antenna_type : optional
        The class to be used to create the antenna objects.

    Attributes
    ----------
    antenna_type
        The class to be used to create the antenna objects.
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.ara.HpolAntenna : ARA Hpol (“quad-slot”) antenna system with
                                   front-end processing.
    pyrex.custom.ara.VpolAntenna : ARA Vpol (“bicone” or “birdcage”) antenna
                                   system with front-end processing.

    Notes
    -----
    This class is designed to be the lowest subset level of a detector. It can
    (and should) be used for the subsets of some other ``Detector`` subclass
    to build up a full detector. Then when its "parent" is iterated, the
    instances of this class will be iterated as though they were all part of
    one flat list.

    """
    def set_positions(self, x, y, antennas_per_string=10,
                      antenna_separation=1, lowest_antenna=-100,
                      antenna_type=VpolAntenna):
        """
        Generates antenna positions along the string.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the string.
        y : float
            Cartesian y-position (m) of the string.
        antennas_per_string : float, optional
            Total number of antennas to be placed on the string.
        antenna_separation : float or list of float, optional
            The vertical separation (m) of antennas on the string. If ``float``,
            all antennas are separated by the same constant value. If ``list``,
            the separations in the list are the separations of neighboring
            antennas starting from the lowest up to the highest.
        lowest_antenna : float, optional
            The Cartesian z-position (m) of the lowest antenna on the string.
        antenna_type : optional
            The class to be used to create the antenna objects.

        """
        self.antenna_type = antenna_type
        for i in range(antennas_per_string):
            z = lowest_antenna + i*antenna_separation
            self.antenna_positions.append((x, y, z))

    def build_antennas(self, power_threshold, amplification=1,
                       naming_scheme=lambda i, ant: ant.name[:4]+"_"+str(i),
                       noisy=True, unique_noise_waveforms=10):
        """
        Creates antenna objects at the set antenna positions.

        The antennas built are ARA Hpol or Vpol antennas, as determined by the
        ``antenna_type``.

        Parameters
        ----------
        power_threshold : float
            Power threshold for antenna trigger conditions.
        amplification : float, optional
            Amplification to be applied to antenna signals.
        naming_scheme : function, optional
            Function used to assign the ``name`` parameter for each antenna.
            Takes the index of the antenna on the string and the antenna
            object itself as parameters and should return a string for the
            antenna's name. By default names antennas "Hpol_X" or "Vpol_X"
            where "X" is the antenna's index.
        noisy : boolean, optional
            Whether or not the antenna should add noise to incoming signals.
        unique_noise_waveforms : int, optional
            The number of expected noise waveforms needed for each received
            signal to have its own noise (per antenna).

        """
        self.subsets = []
        for i, pos in enumerate(self.antenna_positions):
            self.subsets.append(
                self.antenna_type(name=self.antenna_type.__name__, position=pos,
                                  power_threshold=power_threshold,
                                  amplification=amplification,
                                  noisy=noisy,
                                  unique_noise_waveforms=unique_noise_waveforms)
            )
        for i, ant in enumerate(self.subsets):
            ant.name = str(naming_scheme(i, ant))

    def triggered(self, beam_threshold, delays=None, angles=None,
                  require_mc_truth=False):
        """
        Check if the string is triggered based on its current state.

        String is triggered if the maximum value of the phased voltage waveform
        for any of the beams formed (according to `delays` or `angles`) exceeds
        the `beam_threshold` times the expected noise RMS of the beams
        (calculated as the sum of all antenna noise RMS values divided by the
        square root of the number of antennas).

        Parameters
        ----------
        beam_threshold : float
            Factor of expected noise RMS above which a phased beam waveform
            will trigger.
        delays : array_like or None
            Time delays (s) between each pair of antennas to use for beam
            forming. If ``None`` calculates the time delays based on the
            desired beam angles in `angles`.
        angles : array_like or None
            Polar angles (degrees) at which to form phased beams. If ``None``
            and `delays` is ``None``, default beam delays are used based on
            the typical ARA phased array delays (19 delays from -5.94 ns to
            5.94 ns).
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the string is triggered in its current state.

        """
        # Explanation of default delays:
        # Delays from 5.94 ns to -5.94 ns cover the edge case of
        # n=1.78 (z=inf) for elevation angles of 90 to -90 degrees.
        # For another edge case of n=1.35 (z=0), only need to cover
        # 4.5 ns to -4.5 ns really, but having extra won't hurt.
        # (All this assuming a z-spacing of 1 m, otherwise multiply
        # by the spacing to get true time bounds)
        # 19 points in the larger range gives a delay resolution of
        # 660 ps (phased array FPGA sampling rate from
        # https://github.com/vPhase/fpga-sim/blob/master/config.py),
        # or equivalently an angular resolution of about 8 or 6 degrees
        # for the edge cases above.
        # I think this is different from the true phased array trigger,
        # which only looks down, so there are 15 positive (or neg?)
        # delays from 0 to 9.24 ns.
        if delays is None:
            dz = self[0].position[2] - self[1].position[2]
            if angles is None:
                # Use default delays described above
                t_max = 5.94e-9 * np.abs(dz)
                delays = np.linspace(-t_max, t_max, 19)
            else:
                # Calculate delays based on elevation angles
                thetas = np.radians(angles)
                n = np.mean([IceModel.index(ant.position[2]) for ant in self])
                v = 3e8 / n
                delays = dz / v * np.sin(thetas)

        rms = 0

        # Iterate over all waveforms (assume that the antennas are close
        # enough to all see the same rays, i.e. the same index of
        # ant.all_waveforms will be from the same ray for each antenna)
        # TODO: Warn if this assumption will cause problems (shouldn't be often)
        j = -1
        while True:
            j += 1
            # Center around most central antenna that sees ray
            center_i = None
            for i in sorted(range(len(self)),
                            key=lambda x: np.abs(x-len(self)/2)):
                if len(self[i].all_waveforms)>j:
                    center_i = i
                    break
            # Stop waveform iteration once no more waveforms are available
            if center_i is None:
                break

            # Preset the waveforms since the ant.full_waveform call can be
            # computationally expensive
            center_wave = self[center_i].all_waveforms[j]
            waveforms = []
            for i, ant in enumerate(self):
                if i==center_i:
                    waveforms.append(center_wave)
                    continue
                tmin = min(center_wave.times[0] - (center_i-i)*delay
                           for delay in delays)
                tmax = max(center_wave.times[-1] - (center_i-i)*delay
                           for delay in delays)
                n_pts = int((tmax-tmin)/center_wave.dt)
                times = np.linspace(tmin, tmax, n_pts+1)
                waveforms.append(ant.full_waveform(times))

            # Set rms value (if first time around) after noise_masters have
            # been set for the antennas. Pass through front end to ensure
            # more accurate rms values
            if rms==0:
                for ant in self:
                    noise = ant.antenna.make_noise(center_wave.times)
                    processed_noise = ant.front_end(noise)
                    rms += np.sqrt(np.mean(processed_noise.values**2))
                rms /= np.sqrt(len(self))

            # Check each delay for trigger
            for delay in delays:
                total = Signal(center_wave.times, center_wave.values)
                for i, wave in enumerate(waveforms):
                    if i==center_i:
                        continue
                    times = total.times - (center_i-i)*delay
                    add_wave = wave.with_times(times)
                    add_wave.times += (center_i-i)*delay
                    total += add_wave.with_times(total.times)
                if np.max(np.abs(total.values))>np.abs(beam_threshold*rms):
                    return True

        return False



class RegularStation(Detector):
    """
    Station geometry with strings evenly spaced radially around the center.

    Sets the positions of strings around the station based on the parameters.
    Supports any string type and passes extra keyword arguments on to the
    string class. Once the antennas have been built with `build_antennas`,
    the object can be directly iterated over to iterate over the antennas (as
    if the object were just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the station.
    y : float
        Cartesian y-position (m) of the station.
    strings_per_station : float, optional
        Number of strings to be placed evenly around the station.
    station_diameter : float, optional
        Diameter (m) of the circle around which strings are placed.
    string_type : optional
        Class to be used for creating string objects for `subsets`.
    **string_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `string_type` class.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.ara.HpolAntenna : ARA Hpol (“quad-slot”) antenna system with
                                   front-end processing.
    pyrex.custom.ara.VpolAntenna : ARA Vpol (“bicone” or “birdcage”) antenna
                                   system with front-end processing.
    ARAString : String of ARA Hpol and Vpol antennas.

    Notes
    -----
    This class is designed to have string-like objects (which are subclasses of
    ``Detector``) as its `subsets`. Then whenver an object of this class is
    iterated, all the antennas of its strings will be yielded as in a 1D list.

    """
    def set_positions(self, x, y, strings_per_station=4,
                      station_diameter=20, string_type=ARAString,
                      **string_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the station.
        y : float
            Cartesian y-position (m) of the station.
        strings_per_station : float, optional
            Number of strings to be placed evenly around the station.
        station_diameter : float, optional
            Diameter (m) of the circle around which strings are placed.
        string_type : optional
            Class to be used for creating string objects for `subsets`.
        **string_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `string_type` class.

        See Also
        --------
        ARAString.set_positions : Generates antenna positions along the string.

        """
        r = station_diameter/2
        for i in range(strings_per_station):
            angle = 2*np.pi * i/strings_per_station
            x_str = x + r*np.cos(angle)
            y_str = y + r*np.sin(angle)
            self.subsets.append(
                string_type(x_str, y_str, **string_kwargs)
            )

    def triggered(self, polarized_antenna_requirement=1,
                  require_mc_truth=False):
        """
        Check if the station is triggered based on its current state.

        Station is triggered if the number of antennas that have been hit
        (according to ``is_hit``) of a single type (polarization) is greater
        than or equal to the `polarized_antenna_requirement`.

        Parameters
        ----------
        polarized_antenna_requirement : float, optional
            The number of antennas in a single polarization which must be hit
            for the station to trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the station is triggered in its current state.

        See Also
        --------
        pyrex.custom.ara.HpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.
        pyrex.custom.ara.VpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.

        """
        if require_mc_truth:
            hpol_hit = sum(1 for ant in self
                           if isinstance(ant, HpolAntenna)
                           and ant.is_hit_mc_truth)
            vpol_hit = sum(1 for ant in self
                           if isinstance(ant, VpolAntenna)
                           and ant.is_hit_mc_truth)
        else:
            hpol_hit = sum(1 for ant in self
                           if isinstance(ant, HpolAntenna)
                           and ant.is_hit)
            vpol_hit = sum(1 for ant in self
                           if isinstance(ant, VpolAntenna)
                           and ant.is_hit)
        return (hpol_hit>=polarized_antenna_requirement or
                vpol_hit>=polarized_antenna_requirement)



class AlbrechtStation(Detector):
    """
    Station geometry with center phased string and some outrigger strings.

    Station geometry proposed by Albrecht with a phased array string of each
    polarization at the station center, plus a number of outrigger strings
    evenly spaced radially around the station center. Sets the positions of
    strings around the station based on the parameters. Supports any string
    type and passes extra keyword arguments on to the string class. Once the
    antennas have been built with `build_antennas`, the object can be
    directly iterated over to iterate over the antennas (as if the object were
    just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the station.
    y : float
        Cartesian y-position (m) of the station.
    station_diameter : float, optional
        Diameter (m) of the circle around which outrigger strings are
        placed.
    hpol_phased_antennas : float, optional
        Number of Hpol phased antennas for the center string.
    vpol_phased_antennas : float, optional
        Number of Vpol phased antennas for the center string.
    hpol_phased_separation : float or list of float, optional
        Antenna separation (m) for the phased Hpol antennas.
    vpol_phased_separation : float or list of float, optional
        Antenna separation (m) for the phased Vpol antennas.
    hpol_phased_lowest : float, optional
        Cartesian z-position (m) of the lowest phased Hpol antenna.
    vpol_phased_lowest : float, optional
        Cartesian z-position (m) of the lowest phased Vpol antenna.
    outrigger_strings_per_station : float, optional
        Number of outrigger strings to be placed evenly around the station.
    outrigger_string_type : optional
        Class to be used for creating outrigger string objects for
        `subsets`.
    **outrigger_string_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `outrigger_string_type` class. The default values for
        ``antennas_per_string``, ``antenna_separation``, and
        ``lowest_antenna`` are altered for this station geometry.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.ara.HpolAntenna : ARA Hpol (“quad-slot”) antenna system with
                                   front-end processing.
    pyrex.custom.ara.VpolAntenna : ARA Vpol (“bicone” or “birdcage”) antenna
                                   system with front-end processing.
    ARAString : String of ARA Hpol and Vpol antennas.
    PhasedArrayString : Phased string of closely-packed antennas.

    Notes
    -----
    This class is designed to have string-like objects (which are subclasses of
    ``Detector``) as its `subsets`. Then whenver an object of this class is
    iterated, all the antennas of its strings will be yielded as in a 1D list.

    """
    def set_positions(self, x, y, station_diameter=40,
                      hpol_phased_antennas=10, vpol_phased_antennas=10,
                      hpol_phased_separation=1, vpol_phased_separation=1,
                      hpol_phased_lowest=-49, vpol_phased_lowest=-69,
                      outrigger_strings_per_station=3,
                      outrigger_string_type=ARAString,
                      **outrigger_string_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the station.
        y : float
            Cartesian y-position (m) of the station.
        station_diameter : float, optional
            Diameter (m) of the circle around which outrigger strings are
            placed.
        hpol_phased_antennas : float, optional
            Number of Hpol phased antennas for the center string.
        vpol_phased_antennas : float, optional
            Number of Vpol phased antennas for the center string.
        hpol_phased_separation : float or list of float, optional
            Antenna separation (m) for the phased Hpol antennas.
        vpol_phased_separation : float or list of float, optional
            Antenna separation (m) for the phased Vpol antennas.
        hpol_phased_lowest : float, optional
            Cartesian z-position (m) of the lowest phased Hpol antenna.
        vpol_phased_lowest : float, optional
            Cartesian z-position (m) of the lowest phased Vpol antenna.
        outrigger_strings_per_station : float, optional
            Number of outrigger strings to be placed evenly around the station.
        outrigger_string_type : optional
            Class to be used for creating outrigger string objects for
            `subsets`.
        **outrigger_string_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `outrigger_string_type` class. The default values for
            ``antennas_per_string``, ``antenna_separation``, and
            ``lowest_antenna`` are altered for this station geometry.

        See Also
        --------
        ARAString.set_positions : Generates antenna positions along the string.
        PhasedArrayString.set_positions : Generates antenna positions along the
                                          string.

        """
        # Change defaults for outrigger strings
        if "antennas_per_string" not in outrigger_string_kwargs:
            outrigger_string_kwargs["antennas_per_string"] = 8
        if "antenna_separation" not in outrigger_string_kwargs:
            n = outrigger_string_kwargs["antennas_per_string"]
            sep = [1, 29] * int(n/2)
            outrigger_string_kwargs["antenna_separation"] = sep[:n-1]
        if "lowest_antenna" not in outrigger_string_kwargs:
            outrigger_string_kwargs["lowest_antenna"] = -100

        self.subsets.append(
            PhasedArrayString(x, y, antennas_per_string=hpol_phased_antennas,
                              antenna_separation=hpol_phased_separation,
                              lowest_antenna=hpol_phased_lowest,
                              antenna_type=HpolAntenna)
        )
        self.subsets.append(
            PhasedArrayString(x, y, antennas_per_string=vpol_phased_antennas,
                              antenna_separation=vpol_phased_separation,
                              lowest_antenna=vpol_phased_lowest,
                              antenna_type=VpolAntenna)
        )

        r = station_diameter/2
        for i in range(outrigger_strings_per_station):
            angle = 2*np.pi * i/outrigger_strings_per_station
            x_str = x + r*np.cos(angle)
            y_str = y + r*np.sin(angle)
            self.subsets.append(
                outrigger_string_type(x_str, y_str, **outrigger_string_kwargs)
            )

    def triggered(self, beam_threshold, outrigger_antenna_requirement=None,
                  beam_delays=None, beam_angles=None, require_mc_truth=False):
        """
        Check if the station is triggered based on its current state.

        Station is triggered if either of the polarized phased arrays triggers
        with the parameters. If the `outrigger_antenna_requirement` is not
        ``None`` then the station will also trigger if the number of outrigger
        antennas that have been hit (according to ``is_hit``) of a single type
        (polarization) is greater than or equal to the
        `outrigger_antenna_requirement`.

        Parameters
        ----------
        beam_threshold : float
            Factor of expected noise RMS above which a phased beam waveform
            will trigger.
        outrigger_antenna_requirement : float or None, optional
            The number of outrigger antennas in a single polarization which
            must be hit for the station to trigger.
        beam_delays : array_like or None
            Time delays (s) between each pair of antennas to use for beam
            forming. If ``None`` calculates the time delays based on the
            desired beam angles in `angles`.
        beam_angles : array_like or None
            Polar angles (degrees) at which to form phased beams. If ``None``
            and `delays` is ``None``, default beam delays are used based on
            the typical ARA phased array delays.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the station is triggered in its current state.

        See Also
        --------
        PhasedArrayString.triggered : Check if the string is triggered based
                                      on its current state.
        pyrex.custom.ara.HpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.
        pyrex.custom.ara.VpolAntenna.trigger : Check if the antenna system
                                               triggers on a given signal.

        """
        # If outrigger strings can trigger, check those first
        if outrigger_antenna_requirement is not None:
            hpol_outriggers_hit = 0
            vpol_outriggers_hit = 0
            for string in self.subsets[2:]:
                if require_mc_truth:
                    hpol_outriggers_hit += sum(1 for ant in string
                                               if isinstance(ant, HpolAntenna)
                                               and ant.is_hit_mc_truth)
                    vpol_outriggers_hit += sum(1 for ant in string
                                               if isinstance(ant, VpolAntenna)
                                               and ant.is_hit_mc_truth)
                else:
                    hpol_outriggers_hit += sum(1 for ant in string
                                               if isinstance(ant, HpolAntenna)
                                               and ant.is_hit)
                    vpol_outriggers_hit += sum(1 for ant in string
                                               if isinstance(ant, VpolAntenna)
                                               and ant.is_hit)
            if (hpol_outriggers_hit>=outrigger_antenna_requirement or
                    vpol_outriggers_hit>=outrigger_antenna_requirement):
                return True

        # Check for phased array trigger
        return (
            self.subsets[0].triggered(beam_threshold=beam_threshold,
                                      delays=beam_delays, angles=beam_angles,
                                      require_mc_truth=require_mc_truth) or
            self.subsets[1].triggered(beam_threshold=beam_threshold,
                                      delays=beam_delays, angles=beam_angles,
                                      require_mc_truth=require_mc_truth)
        )



class HexagonalGrid(Detector):
    """
    Hexagonal grid of stations or strings.

    Sets the positions of stations by spiralling outward in a hexagonal grid.
    Supports any station type (including string types) and passes extra keyword
    arguments on to the station class. Once the antennas have been built with
    `build_antennas`, the object can be directly iterated over to iterate
    over the antennas (as if the object were just a list of the antennas).

    Parameters
    ----------
    stations : float, optional
        Number of stations to be placed.
    station_separation : float, optional
        Distance (m) between adjacent stations.
    station_type : optional
        Class to be used for creating station objects for `subsets`.
    **station_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `station_type` class.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.ara.HpolAntenna : ARA Hpol (“quad-slot”) antenna system with
                                   front-end processing.
    pyrex.custom.ara.VpolAntenna : ARA Vpol (“bicone” or “birdcage”) antenna
                                   system with front-end processing.
    ARAString : String of ARA Hpol and Vpol antennas.
    RegularStation : Station geometry with strings evenly spaced radially
                     around the center.

    Notes
    -----
    This class is designed to have station-like or string-like objects (which
    are subclasses of ``Detector``) as its `subsets`. Then whenver an object of
    this class is iterated, all the antennas of its strings will be yielded as
    in a 1D list.

    """
    def set_positions(self, stations=1, station_separation=2000,
                      station_type=RegularStation, **station_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        stations : float, optional
            Number of stations to be placed.
        station_separation : float, optional
            Distance (m) between adjacent stations.
        station_type : optional
            Class to be used for creating station objects for `subsets`.
        **station_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `station_type` class.

        See Also
        --------
        ARAString.set_positions : Generates antenna positions along the string.
        RegularStation.set_positions : Generates antenna positions around the
                                       station.

        """
        # Set positions of stations in hexagonal spiral
        if stations<=0:
            raise ValueError("Detector has no stations")
        station_positions = [(0, 0)]
        per_side = 1
        per_ring = 1
        ring_count = 0
        hex_pos = (0, 0)
        while len(station_positions)<stations:
            ring_count += 1
            if ring_count==per_ring:
                per_side += 1
                per_ring = (per_side-1)*6
                ring_count = 0
                hex_pos = (hex_pos[0]+0, hex_pos[1]-1)

            side = int(ring_count/per_ring*6)
            if side==0:
                hex_pos = (hex_pos[0]+1, hex_pos[1]+1)
            elif side==1:
                hex_pos = (hex_pos[0],   hex_pos[1]+1)
            elif side==2:
                hex_pos = (hex_pos[0]-1, hex_pos[1])
            elif side==3:
                hex_pos = (hex_pos[0]-1, hex_pos[1]-1)
            elif side==4:
                hex_pos = (hex_pos[0],   hex_pos[1]-1)
            elif side==5:
                hex_pos = (hex_pos[0]+1, hex_pos[1])

            station_positions.append(
                convert_hex_coords(hex_pos, unit=station_separation)
            )

        for base_pos in station_positions:
            self.subsets.append(
                station_type(base_pos[0], base_pos[1], **station_kwargs)
            )

    def triggered(self, station_requirement=1, require_mc_truth=False,
                  **station_trigger_kwargs):
        """
        Check if the detector is triggered based on its current state.

        Detector is triggered if the number of stations that are triggered
        (according to their ``triggered`` method) is greater than or equal to
        the `station_requirement`. Passes extra keyword arguments on to the
        ``triggered`` methods of the station objects.

        Parameters
        ----------
        station_requirement : float, optional
            The number of stations which must be triggered for the detector to
            trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.
        **station_trigger_kwargs
            Keyword arguments to be passed on to the ``triggered`` methods of
            the station objects in `subsets`.

        Returns
        -------
        boolean
            Whether or not the detector is triggered in its current state.

        See Also
        --------
        RegularStation.triggered : Check if the station is triggered based
                                   on its current state.

        """
        stations_hit = 0
        for station in self.subsets:
            if station.triggered(require_mc_truth=require_mc_truth,
                                 **station_trigger_kwargs):
                stations_hit += 1
            if stations_hit>=station_requirement:
                return True
        return stations_hit>=station_requirement
