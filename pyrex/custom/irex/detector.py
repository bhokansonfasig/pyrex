"""
Module containing customized detector geometry classes for IREX.

Designed to be flexible such that stations can be built up from any string
types and the detector grid can be made up of stations or strings.

"""

import numpy as np
from pyrex.detector import Detector
from .antenna import EnvelopeVpol


class IREXString(Detector):
    """
    String of IREX Vpol antennas.

    Sets the positions of antennas on string based on the parameters. Once the
    antennas have been built with `build_antennas`, the object can be
    directly iterated over to iterate over the antennas (as if the object were
    just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the string.
    y : float
        Cartesian y-position (m) of the string.
    antennas_per_string : float, optional
        Total number of antennas to be placed on the string.
    antenna_separation : float or list of float, optional
        The vertical separation (m) of antennas on the string. If ``float``,
        all antennas are separated by the same constant value. If ``list``,
        the separations in the list are the separations of neighboring
        antennas starting from the lowest up to the highest.
    lowest_antenna : float, optional
        The Cartesian z-position (m) of the lowest antenna on the string.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.irex.EnvelopeHpol : ARA Hpol (“quad-slot”) antenna system with
                                     front-end processing.
    pyrex.custom.irex.EnvelopeVpol : ARA Vpol (“bicone” or “birdcage”) antenna
                                     system with front-end processing.

    Notes
    -----
    This class is designed to be the lowest subset level of a detector. It can
    (and should) be used for the subsets of some other ``Detector`` subclass
    to build up a full detector. Then when its "parent" is iterated, the
    instances of this class will be iterated as though they were all part of
    one flat list.

    """
    def set_positions(self, x, y, antennas_per_string=2,
                      antenna_separation=50, lowest_antenna=-100):
        """
        Generates antenna positions along the string.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the string.
        y : float
            Cartesian y-position (m) of the string.
        antennas_per_string : float, optional
            Total number of antennas to be placed on the string.
        antenna_separation : float or list of float, optional
            The vertical separation (m) of antennas on the string. If ``float``,
            all antennas are separated by the same constant value. If ``list``,
            the separations in the list are the separations of neighboring
            antennas starting from the lowest up to the highest.
        lowest_antenna : float, optional
            The Cartesian z-position (m) of the lowest antenna on the string.

        """
        for i in range(antennas_per_string):
            z = lowest_antenna + i*antenna_separation
            self.antenna_positions.append((x, y, z))

    def build_antennas(self, trigger_threshold, time_over_threshold=0,
                       amplification=1,
                       naming_scheme=lambda i, ant: "ant_"+str(i),
                       orientation_scheme=lambda i, ant: ((0,0,1), (1,0,0)),
                       noisy=True, unique_noise_waveforms=10,
                       envelope_method="analytic"):
        """
        Creates antenna objects at the set antenna positions.

        The antennas built are ARA Hpol or Vpol antennas, as determined by the
        `class_scheme`.

        Parameters
        ----------
        trigger_threshold : float
            Power threshold for antenna trigger conditions.
        time_over_threshold : float, optional
            Time (s) that the voltage waveform must exceed `trigger_threshold`
            for the antenna to trigger.
        amplification : float, optional
            Amplification to be applied to antenna signals.
        naming_scheme : function, optional
            Function used to assign the ``name`` parameter for each antenna.
            Takes the index of the antenna on the string and the antenna
            object itself as parameters and should return a string for the
            antenna's name. By default names antennas "Hpol_X" or "Vpol_X"
            where "X" is the antenna's index.
        orientation_scheme : function, optional
            Function used to decide the orientation to use for each antenna.
            Takes the index of the antenna on the string and the antenna
            object itself as parameters and should return which orientation to
            use for each antenna object. By default aligns all orientations
            with the z-axis.
        noisy : boolean, optional
            Whether or not the antenna should add noise to incoming signals.
        unique_noise_waveforms : int, optional
            The number of expected noise waveforms needed for each received
            signal to have its own noise (per antenna).
        envelope_method : {('hilbert', 'analytic', 'spice') + ('basic',\
                            'biased', 'doubler', 'bridge', 'log amp')}, optional
            String describing the circuit (and calculation method) to be used
            for envelope calculation. If the string contains "hilbert", the
            hilbert envelope is uesd. If the string contains "analytic", an
            analytic form is used to calculate the circuit output. If the
            string contains "spice", ``ngspice`` is used to calculate the
            circuit output. The default value "analytic" uses an analytic diode
            bridge circuit.

        """
        super().build_antennas(antenna_class=EnvelopeVpol,
                               name="Vpol Envelope Antenna",
                               trigger_threshold=trigger_threshold,
                               time_over_threshold=time_over_threshold,
                               amplification=amplification,
                               orientation=(0, 0, 1), noisy=noisy,
                               unique_noise_waveforms=unique_noise_waveforms,
                               envelope_method=envelope_method)
        for i, ant in enumerate(self.subsets):
            ant.name = str(naming_scheme(i, ant))
            ant.antenna.set_orientation(*orientation_scheme(i, ant))

    def triggered(self, antenna_requirement=1, require_mc_truth=False):
        """
        Check if the string is triggered based on its current state.

        String is triggered if the number of antennas that have been hit
        (according to ``is_hit``) is greater than or equal to the
        `antenna_requirement`.

        Parameters
        ----------
        antenna_requirement : float, optional
            The number of antennas which must be hit for the string to trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the string is triggered in its current state.

        See Also
        --------
        pyrex.custom.irex.EnvelopeHpol.trigger : Check if the antenna triggers
                                                 on a given signal.
        pyrex.custom.irex.EnvelopeVpol.trigger : Check if the antenna triggers
                                                 on a given signal.

        """
        if require_mc_truth:
            antennas_hit = sum(1 for ant in self if ant.is_hit_mc_truth)
        else:
            antennas_hit = sum(1 for ant in self if ant.is_hit)
        return antennas_hit>=antenna_requirement



class RegularStation(Detector):
    """
    Station geometry with strings evenly spaced radially around the center.

    Sets the positions of strings around the station based on the parameters.
    Supports any string type and passes extra keyword arguments on to the
    string class. Once the antennas have been built with `build_antennas`,
    the object can be directly iterated over to iterate over the antennas (as
    if the object were just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the station.
    y : float
        Cartesian y-position (m) of the station.
    strings_per_station : float, optional
        Number of strings to be placed evenly around the station.
    station_diameter : float, optional
        Diameter (m) of the circle around which strings are placed.
    string_type : optional
        Class to be used for creating string objects for `subsets`.
    **string_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `string_type` class.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.irex.EnvelopeHpol : ARA Hpol (“quad-slot”) antenna system with
                                     front-end processing.
    pyrex.custom.irex.EnvelopeVpol : ARA Vpol (“bicone” or “birdcage”) antenna
                                     system with front-end processing.
    IREXString : String of IREX Vpol antennas.

    Notes
    -----
    This class is designed to have string-like objects (which are subclasses of
    ``Detector``) as its `subsets`. Then whenver an object of this class is
    iterated, all the antennas of its strings will be yielded as in a 1D list.

    """
    def set_positions(self, x, y, strings_per_station=4,
                      station_diameter=50, string_type=IREXString,
                      **string_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the station.
        y : float
            Cartesian y-position (m) of the station.
        strings_per_station : float, optional
            Number of strings to be placed evenly around the station.
        station_diameter : float, optional
            Diameter (m) of the circle around which strings are placed.
        string_type : optional
            Class to be used for creating string objects for `subsets`.
        **string_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `string_type` class.

        See Also
        --------
        IREXString.set_positions : Generates antenna positions along the
                                   string.

        """
        r = station_diameter/2
        for i in range(strings_per_station):
            angle = 2*np.pi * i/strings_per_station
            x_str = x + r*np.cos(angle)
            y_str = y + r*np.sin(angle)
            self.subsets.append(
                string_type(x_str, y_str, **string_kwargs)
            )

    def triggered(self, antenna_requirement=1, string_requirement=1,
                  require_mc_truth=False):
        """
        Check if the station is triggered based on its current state.

        Station is triggered if the number of antennas that have been hit
        (according to ``is_hit``) is greater than or equal to the
        `antenna_requirement` and the number of strings with antennas that
        have been hit is greater than or equal to the `string_requirement`.

        Parameters
        ----------
        antenna_requirement : float, optional
            The number of antennas which must be hit for the station to
            trigger.
        string_requirement : float, optional
            The number of strings which must be hit for the station to trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the station is triggered in its current state.

        See Also
        --------
        pyrex.custom.irex.EnvelopeHpol.trigger : Check if the antenna triggers
                                                 on a given signal.
        pyrex.custom.irex.EnvelopeVpol.trigger : Check if the antenna triggers
                                                 on a given signal.
        IREXString.triggered : Check if the string is triggered based on its
                               current state.

        """
        if require_mc_truth:
            antennas_hit = sum(1 for ant in self if ant.is_hit_mc_truth)
        else:
            antennas_hit = sum(1 for ant in self if ant.is_hit)
        strings_hit = sum(1 for string in self.subsets if
                          string.triggered(1,
                                           require_mc_truth=require_mc_truth))
        return (antennas_hit>=antenna_requirement and
                strings_hit>=string_requirement)



class CoxeterStation(Detector):
    """
    Station geometry with center string and the rest evenly spaced radially.

    Sets the positions of strings around the station based on the parameters.
    Supports any string type and passes extra keyword arguments on to the
    string class. Once the antennas have been built with `build_antennas`,
    the object can be directly iterated over to iterate over the antennas (as
    if the object were just a list of the antennas).

    Parameters
    ----------
    x : float
        Cartesian x-position (m) of the station.
    y : float
        Cartesian y-position (m) of the station.
    strings_per_station : float, optional
        Number of strings to be placed around the station. Note that the first
        string is always placed at the center and the rest of the strings are
        placed evenly around that center string.
    station_diameter : float, optional
        Diameter (m) of the circle around which strings are placed.
    string_type : optional
        Class to be used for creating string objects for `subsets`.
    **string_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `string_type` class.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    See Also
    --------
    pyrex.custom.irex.EnvelopeHpol : ARA Hpol (“quad-slot”) antenna system with
                                     front-end processing.
    pyrex.custom.irex.EnvelopeVpol : ARA Vpol (“bicone” or “birdcage”) antenna
                                     system with front-end processing.
    IREXString : String of IREX Vpol antennas.

    Notes
    -----
    This class is designed to have string-like objects (which are subclasses of
    ``Detector``) as its `subsets`. Then whenver an object of this class is
    iterated, all the antennas of its strings will be yielded as in a 1D list.

    """
    def set_positions(self, x, y, strings_per_station=4,
                      station_diameter=50, string_type=IREXString,
                      **string_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        x : float
            Cartesian x-position (m) of the station.
        y : float
            Cartesian y-position (m) of the station.
        strings_per_station : float, optional
            Number of strings to be placed around the station. Note that the
            first string is always placed at the center and the rest of the
            strings are placed evenly around that center string.
        station_diameter : float, optional
            Diameter (m) of the circle around which strings are placed.
        string_type : optional
            Class to be used for creating string objects for `subsets`.
        **string_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `string_type` class.

        See Also
        --------
        IREXString.set_positions : Generates antenna positions along the
                                   string.

        """
        r = station_diameter/2
        for i in range(strings_per_station):
            if i==0:
                x_str = x
                y_str = y
            else:
                angle = 0 if i==1 else 2*np.pi * (i-1)/(strings_per_station-1)
                x_str = x + r*np.cos(angle)
                y_str = y + r*np.sin(angle)
            self.subsets.append(
                string_type(x_str, y_str, **string_kwargs)
            )

    def triggered(self, antenna_requirement=1, string_requirement=1,
                  require_mc_truth=False):
        """
        Check if the station is triggered based on its current state.

        Station is triggered if the number of antennas that have been hit
        (according to ``is_hit``) is greater than or equal to the
        `antenna_requirement` and the number of strings with antennas that
        have been hit is greater than or equal to the `string_requirement`.
        No distinction is made for the center string.

        Parameters
        ----------
        antenna_requirement : float, optional
            The number of antennas which must be hit for the station to
            trigger.
        string_requirement : float, optional
            The number of strings which must be hit for the station to trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.

        Returns
        -------
        boolean
            Whether or not the station is triggered in its current state.

        See Also
        --------
        pyrex.custom.irex.EnvelopeHpol.trigger : Check if the antenna triggers
                                                 on a given signal.
        pyrex.custom.irex.EnvelopeVpol.trigger : Check if the antenna triggers
                                                 on a given signal.
        IREXString.triggered : Check if the string is triggered based on its
                               current state.

        """
        if require_mc_truth:
            antennas_hit = sum(1 for ant in self if ant.is_hit_mc_truth)
        else:
            antennas_hit = sum(1 for ant in self if ant.is_hit)
        strings_hit = sum(1 for string in self.subsets if
                          string.triggered(1,
                                           require_mc_truth=require_mc_truth))
        return (antennas_hit>=antenna_requirement and
                strings_hit>=string_requirement)



class StationGrid(Detector):
    """
    Rectangular grid of stations or strings.

    Sets the positions of stations in a square layout if possible, otherwise
    in a rectangular layout (drops any extra stations). Supports any station
    type (including string types) and passes extra keyword arguments on to the
    station class. Once the antennas have been built with `build_antennas`,
    the object can be directly iterated over to iterate over the antennas (as
    if the object were just a list of the antennas).

    Parameters
    ----------
    stations : float, optional
        Number of stations to be placed.
    station_separation : float, optional
        Distance (m) between adjacent stations.
    station_type : optional
        Class to be used for creating station objects for `subsets`.
    **station_kwargs
        Keyword arguments to be passed on to the ``__init__`` methods of
        the `station_type` class.

    Attributes
    ----------
    antenna_positions : list
        List (potentially with sub-lists) of the positions of the antennas
        generated by the `set_positions` method.
    subsets : list
        List of the antenna or detector objects which make up the detector.
    test_antenna_positions : boolean
        Class attribute for whether or not an error should be raised if antenna
        positions are found above the surface of the ice (where simulation
        behavior is ill-defined). Defaults to ``True``.

    Raises
    ------
    ValueError
        If ``test_antenna_positions`` is ``True`` and an antenna is found to be
        above the ice surface.

    Warnings
    --------
    If the number of `stations` provided does not divide nicely into a
    rectangle, extra stations may be dropped without warning. For example, if
    `stations` is 5, then a 2x2 grid will be created and the last station will
    be silently dropped.

    See Also
    --------
    IREXString : String of IREX Vpol antennas.
    RegularStation : Station geometry with strings evenly spaced radially
                     around the center.
    CoxeterStation : Station geometry with center string and the rest evenly
                     spaced radially.

    Notes
    -----
    This class is designed to have station-like or string-like objects (which
    are subclasses of ``Detector``) as its `subsets`. Then whenver an object of
    this class is iterated, all the antennas of its strings will be yielded as
    in a 1D list.

    """
    def set_positions(self, stations=1, station_separation=500,
                      station_type=IREXString, **station_kwargs):
        """
        Generates antenna positions around the station.

        Parameters
        ----------
        stations : float, optional
            Number of stations to be placed.
        station_separation : float, optional
            Distance (m) between adjacent stations.
        station_type : optional
            Class to be used for creating station objects for `subsets`.
        **station_kwargs
            Keyword arguments to be passed on to the ``__init__`` methods of
            the `station_type` class.

        See Also
        --------
        IREXString.set_positions : Generates antenna positions along the
                                   string.
        RegularStation.set_positions : Generates antenna positions around the
                                       station.
        CoxeterStation.set_positions : Generates antenna positions around the
                                       station.

        """
        n_x = int(np.sqrt(stations))
        n_y = int(stations/n_x)
        dx = station_separation
        dy = station_separation
        for i in range(n_x):
            x = -dx*n_x/2 + dx/2 + dx*i
            for j in range(n_y):
                y = -dy*n_y/2 + dy/2 + dy*j
                self.subsets.append(
                    station_type(x, y, **station_kwargs)
                )

    def triggered(self, station_requirement=1, require_mc_truth=False,
                  **station_trigger_kwargs):
        """
        Check if the detector is triggered based on its current state.

        Detector is triggered if the number of stations that are triggered
        (according to their ``triggered`` method) is greater than or equal to
        the `station_requirement`. Passes extra keyword arguments on to the
        ``triggered`` methods of the station objects.

        Parameters
        ----------
        station_requirement : float, optional
            The number of stations which must be triggered for the detector to
            trigger.
        require_mc_truth : boolean, optional
            Whether or not the trigger should be based on the Monte-Carlo
            truth. If ``True``, noise-only triggers are removed.
        **station_trigger_kwargs
            Keyword arguments to be passed on to the ``triggered`` methods of
            the station objects in `subsets`.

        Returns
        -------
        boolean
            Whether or not the detector is triggered in its current state.

        See Also
        --------
        IREXString.triggered : Check if the string is triggered based on its
                               current state.
        RegularStation.triggered : Check if the station is triggered based on
                                   its current state.
        CoxeterStation.triggered : Check if the station is triggered based on
                                   its current state.

        """
        stations_hit = 0
        for station in self.subsets:
            if station.triggered(require_mc_truth=require_mc_truth,
                                 **station_trigger_kwargs):
                stations_hit += 1
            if stations_hit>=station_requirement:
                return True
        return stations_hit>=station_requirement
