"""
Module containing Askaryan model signals classes.

Contains various Askaryan models based in both the frequency and time domains.
All classes inherit from the Signal class, meaning they must all be converted
into the time domain at the end of initialization.

"""

import logging
import warnings
import numpy as np
import scipy.constants
import scipy.fft
import scipy.signal
from pyrex.signals import FunctionSignal
from pyrex.ice_model import ice

logger = logging.getLogger(__name__)


class ZHSAskaryanSignal(FunctionSignal):
    """
    Class for generating Askaryan signals according to ZHS parameterization.

    Stores the time-domain information for an Askaryan electric field (V/m)
    produced by the electromagnetic shower initiated by a neutrino.

    Parameters
    ----------
    times : array_like
        1D array of times (s) for which the signal is defined.
    particle : Particle
        ``Particle`` object responsible for the shower which produces the
        Askaryan signal. Should have an ``energy`` in GeV, ``vertex`` in m,
        and ``id``, plus an ``interaction`` with an ``em_frac`` and
        ``had_frac``.
    viewing_angle : float
        Observation angle (radians) measured relative to the shower axis.
    viewing_distance : float, optional
        Distance (m) between the shower vertex and the observation point (along
        the ray path).
    ice_model : optional
        The ice model to be used for describing the index of refraction of the
        medium.
    t0 : float, optional
        Pulse offset time (s), i.e. time at which the shower takes place.

    Attributes
    ----------
    times, values : ndarray
        1D arrays of times (s) and corresponding values which define the signal.
    value_type : Signal.Type.field
        Type of signal, representing the units of the values.
    Type : Enum
        Different value types available for `value_type` of signal objects.
    energy : float
        Energy (GeV) of the electromagnetic shower producing the pulse.
    vector_potential
    dt
    frequencies
    spectrum
    envelope

    Raises
    ------
    ValueError
        If the `particle` object is not a neutrino or antineutrino with a
        charged-current or neutral-current interaction.

    See Also
    --------
    pyrex.FunctionSignal : Class for signals generated by a function.
    pyrex.Particle : Class for storing particle attributes.

    Notes
    -----
    Calculates the Askaryan signal based on the ZHS parameterization [1]_.
    Uses equations 20 and 21 to calculate the electric field close to the
    Cherenkov angle.

    References
    ----------
    .. [1] E. Zas, F. Halzen, T. Stanev, "Electromagnetic pulses from
        high-energy showers: implications for neutrino detection", Physical
        Review D **45**, 362-376 (1992). :doi:`10.1103/PhysRevD.45.362`

    """
    def __init__(self, times, particle, viewing_angle, viewing_distance=1,
                 ice_model=ice, t0=0):
        # Theta should represent the angle from the shower axis, and so should
        # always be positive
        theta = np.abs(viewing_angle)

        if theta > np.pi:
            raise ValueError("Angles greater than 180 degrees not supported")

        # Calculate shower energy based on particle's total shower fractions
        self.energy = particle.energy * (particle.interaction.em_frac +
                                         particle.interaction.had_frac)

        # Fail gracefully if there is no shower (the energy is zero)
        if self.energy==0:
            super().__init__(times, np.zeros(len(times)),
                             value_type=self.Type.field)
            return

        # Calculate index of refraction at the shower position for the
        # Cherenkov angle calculation and others
        n = ice_model.index(particle.vertex[2])

        # Calculate theta_c = arccos(1/n)
        theta_c = np.arccos(1/n)

        # Parameterization relative frequency value
        nu_0 = 500e6

        def get_signal(times):
            # Calculate dt of times array
            dt = times[1] - times[0]

            # Calculate frequencies for frequency-domain calculations
            freqs = scipy.fft.fftfreq(2*len(times), d=dt)

            # Field as a function of frequency at Cherenkov angle
            # (ZHS equation 20)
            ratio = np.abs(freqs)/nu_0
            e_omega = 1.1e-7 * self.energy/1000 * ratio * 1/(1 + 0.4*ratio**2)
            e_omega /= viewing_distance

            # Convert to volts per meter per hertz
            # (from volts per meter per megahertz)
            e_omega *= 1e-6

            # Parameterize away from Cherenkov angle using Gaussian peak
            # (ZHS equation 21)
            e_omega *= np.exp(-0.5*((viewing_angle-theta_c)*ratio
                                    /np.radians(2.4))**2)

            # Shift the times so the signal comes at t0
            shift = int((t0-times[0]) / dt) - int(len(times)/2)
            if np.abs(shift)>len(times):
                return np.zeros(len(times))
            freq_vals = e_omega * np.exp(-1j*2*np.pi*freqs*(t0-times[0]))

            # Normalize the inverse fourier transform by dt so the time-domain
            # amplitude stays the same for different sampling rates
            return np.real(scipy.fft.ifft(freq_vals)[:len(times)]) / dt

        super().__init__(times, get_signal, value_type=self.Type.field)



class AVZAskaryanSignal(FunctionSignal):
    """
    Class for generating Askaryan signals according to AVZ parameterization.

    Stores the time-domain information for an Askaryan electric field (V/m)
    produced by the electromagnetic and hadronic showers initiated by a
    neutrino.

    Parameters
    ----------
    times : array_like
        1D array of times (s) for which the signal is defined.
    particle : Particle
        ``Particle`` object responsible for the showers which produce the
        Askaryan signal. Should have an ``energy`` in GeV, ``vertex`` in m,
        and ``id``, plus an ``interaction`` with an ``em_frac`` and
        ``had_frac``.
    viewing_angle : float
        Observation angle (radians) measured relative to the shower axis.
    viewing_distance : float, optional
        Distance (m) between the shower vertex and the observation point (along
        the ray path).
    ice_model : optional
        The ice model to be used for describing the index of refraction of the
        medium.
    t0 : float, optional
        Pulse offset time (s), i.e. time at which the showers take place.

    Attributes
    ----------
    times, values : ndarray
        1D arrays of times (s) and corresponding values which define the signal.
    value_type : Signal.Type.field
        Type of signal, representing the units of the values.
    Type : Enum
        Different value types available for `value_type` of signal objects.
    em_energy : float
        Energy (GeV) of the electromagnetic shower producing the pulse.
    had_energy : float
        Energy (GeV) of the hadronic shower producing the pulse.
    dt
    frequencies
    spectrum
    envelope

    Raises
    ------
    ValueError
        If the `particle` object is not a neutrino or antineutrino with a
        charged-current or neutral-current interaction.

    See Also
    --------
    pyrex.FunctionSignal : Class for signals generated by a function.
    pyrex.Particle : Class for storing particle attributes.

    Notes
    -----
    Calculates the Askaryan signal based on the AVZ parameterization [1]_.
    Matches the NuRadioMC implementation named 'Alvarez2000', including the
    LPM effect correction added based on an earlier paper by Alvarez-Muniz and
    Zas [2]_.

    References
    ----------
    .. [1] J. Alvarez-Muniz et al, "Calculation Methods for Radio Pulses from
        High Energy Showers." Physical Review D **62**, 063001 (2000).
        :arxiv:`astro-ph/0003315` :doi:`10.1103/PhysRevD.62.063001`
    .. [2] J. Alvarez-Muniz & E. Zas, "The LPM effect for EeV hadronic showers
        in ice: implications for radio detection of neutrinos." Physics Letters
        **B434**, 396-406 (1998). :arxiv:`astro-ph/9806098`
        :doi:`10.1016/S0370-2693(98)00905-8`

    """
    def __init__(self, times, particle, viewing_angle, viewing_distance=1,
                 ice_model=ice, t0=0):
        # Theta should represent the angle from the shower axis, and so should
        # always be positive
        theta = np.abs(viewing_angle)

        if theta > np.pi:
            raise ValueError("Angles greater than 180 degrees not supported")

        # Calculate shower energy based on particle's total shower fractions
        self.em_energy = particle.energy * particle.interaction.em_frac
        self.had_energy = particle.energy * particle.interaction.had_frac

        # Calculate index of refraction at the shower position for the
        # Cherenkov angle calculation and others
        n = ice_model.index(particle.vertex[2])

        # Calculate theta_c = arccos(1/n)
        theta_c = np.arccos(1/n)

        def get_signal(times):
            # Calculate corresponding frequencies, ignoring zero frequency
            N = len(times)
            dt = times[1]-times[0]
            freqs = np.fft.rfftfreq(N, dt)[1:]

            # LPM effect parameters
            E_lpm = 2e15 # eV
            dThetaEM = (np.radians(2.7) * 500e6 / freqs
                        * (E_lpm / (0.14 * self.em_energy*1e9 + E_lpm)) ** 0.3)

            if self.had_energy==0:
                epsilon = -np.inf
            else:
                epsilon = np.log10(self.had_energy / 1e3)
            dThetaHad = 0
            if (epsilon >= 0 and epsilon <= 2):
                dThetaHad = 500e6 / freqs * (2.07 - 0.33 * epsilon
                                             + 7.5e-2 * epsilon ** 2)
            elif (epsilon > 2 and epsilon <= 5):
                dThetaHad = 500e6 / freqs * (1.74 - 1.21e-2 * epsilon)
            elif (epsilon > 5 and epsilon <= 7):
                dThetaHad = 500e6 / freqs * (4.23 - 0.785 * epsilon
                                             + 5.5e-2 * epsilon ** 2)
            elif epsilon > 7:
                dThetaHad = (500e6 / freqs
                             * (4.23 - 0.785 * 7 + 5.5e-2 * 7 ** 2)
                             * (1 + (epsilon - 7) * 0.075))
            dThetaHad = np.radians(dThetaHad)

            f0 = 1.15e9 # Hz
            em_tmp = np.zeros(len(freqs) + 1)
            had_tmp = np.zeros(len(freqs) + 1)
            # Electromagnetic shower handling
            if particle.interaction.em_frac>0:
                E = (2.53e-7 * self.em_energy/1e3 * freqs / f0
                    / (1 + (freqs / f0) ** 1.44)) # V/m/Hz
                E /= 1e6 # convert to V/m/MHz
                E *= np.sin(theta) / np.sin(theta_c)
                em_tmp[1:] += (E / viewing_distance
                               * np.exp(-np.log(2) *
                                        ((theta - theta_c) / dThetaEM)**2))
            # Hadronic shower handling (when hadronic energy is above 1 TeV)
            if particle.interaction.had_frac>0 and np.any(dThetaHad!=0):
                E = (2.53e-7 * self.had_energy/1e3 * freqs / f0
                    / (1 + (freqs / f0) ** 1.44)) # V/m/Hz
                E /= 1e6 # convert to V/m/MHz
                E *= np.sin(theta) / np.sin(theta_c)
                had_tmp[1:] += (E / viewing_distance
                                * np.exp(-np.log(2) *
                                         ((theta - theta_c) / dThetaHad)**2))

                def missing_energy_factor(E_0):
                    # Missing energy factor for hadronic cascades
                    # Taken from DOI: 10.1016/S0370-2693(98)00905-8
                    epsilon = np.log10(E_0/1e3)
                    f_epsilon = (-1.27e-2 - 4.76e-2*(epsilon+3)
                                 - 2.07e-3*(epsilon+3)**2
                                 + 0.52*np.sqrt(epsilon+3))
                    return f_epsilon

                had_tmp[1:] *= missing_energy_factor(self.had_energy)

            # Combine showers
            tmp = em_tmp + had_tmp

            # Factor of 0.5 is introduced to compensate the unusual fourier
            # transform normalization used in the ZHS code
            tmp *= 0.5

            # Set phases to 90 degrees
            trace = np.fft.irfft(tmp * np.exp(0.5j * np.pi)) / dt

            # Shift waveform to the center of the trace
            shift = int(len(trace)/2)
            trace = np.roll(trace, shift)

            # Shift to proper t0
            shift = int((t0-times[0]) / dt) - shift
            if np.abs(shift)>len(trace):
                trace = np.zeros(len(trace), dtype=trace.dtype)
            else:
                long_trace = np.concatenate((trace, np.zeros(len(trace))))
                trace = np.roll(long_trace, shift)[:len(trace)]

            # Correct trace length for odd-valued N by extrapolating slope
            if len(trace)==N-1:
                trace = np.concatenate((trace, [2*trace[-1]-trace[-2]]))

            return trace

        super().__init__(times, get_signal, value_type=self.Type.field)


class ARZAskaryanSignal(FunctionSignal):
    """
    Class for generating Askaryan signals according to ARZ parameterization.

    Stores the time-domain information for an Askaryan electric field (V/m)
    produced by the electromagnetic and hadronic showers initiated by a
    neutrino.

    Parameters
    ----------
    times : array_like
        1D array of times (s) for which the signal is defined.
    particle : Particle
        ``Particle`` object responsible for the showers which produce the
        Askaryan signal. Should have an ``energy`` in GeV, ``vertex`` in m,
        and ``id``, plus an ``interaction`` with an ``em_frac`` and
        ``had_frac``.
    viewing_angle : float
        Observation angle (radians) measured relative to the shower axis.
    viewing_distance : float, optional
        Distance (m) between the shower vertex and the observation point (along
        the ray path).
    ice_model : optional
        The ice model to be used for describing the index of refraction of the
        medium.
    t0 : float, optional
        Pulse offset time (s), i.e. time at which the showers take place.

    Attributes
    ----------
    times, values : ndarray
        1D arrays of times (s) and corresponding values which define the signal.
    value_type : Signal.Type.field
        Type of signal, representing the units of the values.
    Type : Enum
        Different value types available for `value_type` of signal objects.
    em_energy : float
        Energy (GeV) of the electromagnetic shower producing the pulse.
    had_energy : float
        Energy (GeV) of the hadronic shower producing the pulse.
    oncone_range : float
        Maximum angular deviation (radians) from the Cherenkov angle which
        should be forced to the Cherenkov angle form factor parameterization.
    vector_potential
    dt
    frequencies
    spectrum
    envelope

    Raises
    ------
    ValueError
        If the `particle` object is not a neutrino or antineutrino with a
        charged-current or neutral-current interaction.

    See Also
    --------
    pyrex.FunctionSignal : Class for signals generated by a function.
    pyrex.Particle : Class for storing particle attributes.

    Notes
    -----
    Calculates the Askaryan signal based on the ARZ parameterization [1]_.
    Uses a Greisen model for the electromagnetic shower profile [2]_, [3]_ and
    a Gaisser-Hillas model for the hadronic shower profile [4]_, [5]_.
    Calculates the electric field from the vector potential using the
    convolution method outlined in section 4 of the ARZ paper, which results
    in the most efficient calculation of the parameterization.

    References
    ----------
    .. [1] J. Alvarez-Muniz et al, "Practical and accurate calculations
        of Askaryan radiation." Physical Review D **84**, 103003 (2011).
        :arxiv:`1106.6283` :doi:`10.1103/PhysRevD.84.103003`
    .. [2] K. Greisen, "The Extensive Air Showers." Prog. in Cosmic Ray Phys.
        **III**, 1 (1956).
    .. [3] K.D. de Vries et al, "On the feasibility of RADAR detection of
        high-energy neutrino-induced showers in ice." Astropart. Phys. **60**,
        25-31 (2015). :arxiv:`1312.4331`
        :doi:`10.1016/j.astropartphys.2014.05.009`
    .. [4] T.K. Gaisser & A.M. Hillas "Reliability of the Method of Constant
        Intensity Cuts for Reconstructing the Average Development of Vertical
        Showers." ICRC proceedings, 353 (1977).
    .. [5] J. Alvarez-Muniz & E. Zas, "EeV Hadronic Showers in Ice: The LPM
        effect." ICRC proceedings, 17-25 (1999). :arxiv:`astro-ph/9906347`

    """
    oncone_range = (np.arccos((1-10*scipy.constants.c*np.finfo(np.float_).eps)
                              /1.78) - np.arccos(1/1.78))

    def __init__(self, times, particle, viewing_angle, viewing_distance=1,
                 ice_model=ice, t0=0):
        # Calculation of pulse based on https://arxiv.org/pdf/1106.6283v3.pdf
        # Vector potential is given by:
        #   A(theta,t) = convolution(Q(z(1-n*cos(theta))/c)),
        #                            RAC(z(1-n*cos(theta))/c))
        #                * sin(theta) / sin(theta_c) / R / integral(Q(z))
        #                * c / (1-n*cos(theta))

        # Theta should represent the angle from the shower axis, and so should
        # always be positive
        theta = np.abs(viewing_angle)

        if theta > np.pi:
            raise ValueError("Angles greater than 180 degrees not supported")

        # Calculate shower energies based on particle's electromagnetic and
        # hadronic shower fractions
        self.em_energy = particle.energy * particle.interaction.em_frac
        self.had_energy = particle.energy * particle.interaction.had_frac

        # Calculate index of refraction at the shower position for the
        # Cherenkov angle calculation and others
        n = ice_model.index(particle.vertex[2])

        # Calculate the resulting pulse values from an electromagnetic shower
        # and a hadronic shower, then add them
        def get_signal_from_showers(times):
            em_vals = self.shower_signal(times=times, energy=self.em_energy,
                                         profile_function=self.em_shower_profile,
                                         potential_function=self.em_shower_RAC,
                                         viewing_angle=theta,
                                         viewing_distance=viewing_distance,
                                         n=n, t0=t0)
            had_vals = self.shower_signal(times=times, energy=self.had_energy,
                                          profile_function=self.had_shower_profile,
                                          potential_function=self.had_shower_RAC,
                                          viewing_angle=theta,
                                          viewing_distance=viewing_distance,
                                          n=n, t0=t0)
            return em_vals + had_vals

        super().__init__(times, get_signal_from_showers,
                         value_type=self.Type.field)


    def shower_signal(self, times, energy, profile_function, potential_function,
                      viewing_angle, viewing_distance, n, t0):
        """
        Calculate the signal values for some shower type.

        Calculates the time-domain values for an Askaryan electric field (V/m)
        produced by a particular shower initiated by a neutrino.

        Parameters
        ----------
        times : array_like
            1D array of times (s) for which the signal is defined.
        energy : float
            Energy (GeV) of the shower.
        profile_function : function
            Function to be used for calculating the longitudinal shower
            profile. Should take a distance (m) and energy (GeV) and return the
            profile value at that depth for a shower of that energy.
        potential_function : function
            Function to be used for calculating the vector potential at the
            Cherenkov angle. Should take a time (s) and energy (GeV) and return
            the vector potential at the Cherenkov angle for a shower of that
            energy at that time.
        viewing_angle : float
            Observation angle (radians) measured relative to the shower axis.
            Should be positive-valued.
        viewing_distance : float
            Distance (m) between the shower vertex and the observation point
            (along the ray path).
        n : float
            The index of refraction of the ice at the location of the shower.
        t0 : float
            Pulse offset time (s), i.e. time at which the shower takes place.

        Returns
        -------
        array_like
            1D array of values of the signal created by the shower
            corresponding to the given `times`. Length ends up being one less
            than the length of `times` due to implementation.

        """
        # Calculation of pulse based on https://arxiv.org/pdf/1106.6283v3.pdf
        # Vector potential is given by:
        #   A(theta,t) = convolution(Q(z), RAC(z*(1-n*cos(theta))/c))
        #                * sin(theta) / sin(theta_c) / R / integral(Q(z))
        #                * c / (1-n*cos(theta))

        # Fail gracefully if there is no shower (the energy is zero)
        if energy==0:
            return np.zeros(len(times))

        theta = viewing_angle

        # Conversion factor from z to t for RAC:
        # (1-n*cos(theta)) / c
        z_to_t = (1 - n*np.cos(theta))/scipy.constants.c

        # Calculate the time step and number of points for vector potential
        dt = times[1] - times[0]
        N = len(times) + 1

        # For signals very close to the Cherenkov angle, simply use the
        # potential_function at the Cherenkov angle. This saves time in the
        # convolution, and the numerical accuracy of calculations involving
        # z_to_t at this point is questionable anyway
        if np.abs(theta - np.arccos(1/n))<=self.oncone_range:
            logger.debug("Using RAC parameterization directly for theta=%f "+
                         "(z_to_t=%e)", theta, z_to_t)
            times = np.concatenate((times, [times[-1]+dt])) - t0
            A = potential_function(times, energy) / viewing_distance
            return -np.diff(A) / dt

        # Calculate the corresponding z-step (dz = dt / z_to_t)
        # If the z-step is too large compared to the expected shower maximum
        # length, then the result will be bad. Set dt_divider so that
        # dz / max_length <= 0.01 (with dz=dt/z_to_t)
        # Additionally if the z-step is too large compared to the RAC width,
        # the result will be bad. So set dt_divider so that
        # dz <= 10 ps / z_to_t
        dt_divider_Q = int(np.abs(100*dt/self.max_length(energy)/z_to_t)) + 1
        dt_divider_RAC = int(np.abs(dt/1e-11)) + 1
        dt_divider = max(dt_divider_Q, dt_divider_RAC)
        dz = dt / dt_divider / z_to_t
        if dt_divider!=1:
            logger.debug("z-step of %g too large; dt_divider changed to %g",
                         dt / z_to_t, dt_divider)

        # Prepare the charge-profile array up to 5 times the nominal shower
        # maximum length (to reduce errors) in the positive and negative
        # directions. Combined with the above, this guarantees that n_Q >= 1000
        z_max = 5*self.max_length(energy)
        n_Q = int(np.abs(z_max/dz)) * 2
        n_Q_negative = int(n_Q/2)
        z_Q_vals = (np.arange(n_Q) - n_Q_negative) * np.abs(dz)

        # Prepare for RAC at a specific number of t values (n_RAC) determined
        # such that the full convolution will have the same size as the times
        # array, when appropriately rescaled by dt_divider.
        # t_RAC_vals is forced to a reasonable range around the peak of RAC
        # (at 0 ns) to ensure accuracy. The predetermined reasonable range
        # based on the RAC function is +/- 10 ns around the peak
        t_tolerance = 10e-9
        t_start = times[0] - t0
        n_shift = int((t_start+t_tolerance)/dz/z_to_t)
        n_extra = int(2*t_tolerance/dz/z_to_t) + 1 + n_Q - N*dt_divider
        n_RAC = N*dt_divider + 1 - n_Q + n_extra
        t_RAC_vals = (np.arange(n_RAC) - n_shift) * dz * z_to_t + t_start

        # Skip further calculation if the shift is further than the size of the
        # convolution array (i.e. all field values would be zero)
        if (-n_shift-n_Q_negative>=N*dt_divider or
                n_shift+n_Q_negative-n_extra>=N*dt_divider):
            return np.zeros(len(times))

        # Calculate values for the charge-profile array
        # Since this is normalized by LQ_tot in the end, there is no need to
        # change from number of particles to charge
        Q = profile_function(np.sign(z_to_t)*z_Q_vals, energy)

        # Fail gracefully if the energy is less than the critical energy for
        # shower formation (i.e. all Q values are zero)
        if np.all(Q==0) and len(Q)>0:
            return np.zeros(len(times))

        # Calculate values for the RAC array
        RA_C = potential_function(t_RAC_vals, energy)

        # Convolve Q and RAC to get unnormalized vector potential
        if dt_divider!=1:
            logger.debug("Convolving %i Q points with %i RA_C points",
                         n_Q, n_RAC)
        convolution = scipy.signal.convolve(Q, RA_C, mode='full')

        # Shift convolution by the amount given by n_shift and n_Q_negative
        # (assuming all values outside the set range are zero) and also
        # zero-pad or remove values according to the values added/removed by
        # n_extra
        n_shift += n_Q_negative
        if n_shift>0:
            if n_shift-n_extra>=0:
                convolution = np.concatenate((
                    convolution[n_shift:],
                    np.zeros(n_shift-n_extra)
                ))
            else:
                convolution = convolution[n_shift:n_shift-n_extra]
        else:
            if n_shift-n_extra>=0:
                convolution = np.concatenate((
                    np.zeros(-n_shift),
                    convolution,
                    np.zeros(n_shift-n_extra)
                ))
            else:
                convolution = np.concatenate((
                    np.zeros(-n_shift),
                    convolution[:n_shift-n_extra]
                ))

        # Reduce the number of values in the convolution based on the dt_divider
        # so that the number of values matches the length of the times array.
        if dt_divider!=1:
            # Downsample by simple decimation. Scipy resample method assumes
            # periodic signal which is problematic when signal is at the edge
            # of the times array. Scipy decimate method doesn't appear to be
            # reliable for large decimation factors
            convolution = convolution[::dt_divider]

        # Calculate LQ_tot (the excess longitudinal charge along the showers)
        LQ_tot = np.trapz(Q, dx=dz)

        # Calculate sin(theta_c) = sqrt(1-cos^2(theta_c)) = sqrt(1-1/n^2)
        sin_theta_c = np.sqrt(1 - 1/n**2)

        # Scale the convolution by the necessary factors to get the true
        # vector potential A.
        # Since the numerical convolution performs a sum rather than an
        # integral it needs to be scaled by dz = dt/dt_divider/z_to_t for the
        # proper normalization. The dt factor will be canceled by the 1/dt in
        # the conversion to electric field however, so it can be left out.
        A = (convolution * -1 * np.sin(theta) / sin_theta_c / LQ_tot
             / z_to_t / dt_divider)

        # Calculate electric field by taking derivative of vector potential,
        # and divide by the viewing distance (R)
        return np.diff(A) / viewing_distance


    @property
    def vector_potential(self):
        """
        The vector potential of the signal.

        Recovered from the electric field, mostly just for testing purposes.

        """
        return np.cumsum(np.concatenate(([0],self.values)))[:-1] * -self.dt


    @staticmethod
    def em_shower_RAC(time, energy):
        """
        Calculates R*A_C at the given time and energy.

        The R*A_C value is the observation distance R (m) times the vector
        potential (V*s/m) at the Cherenkov angle. This function calculates the
        R*A_C values for an electromagnetic shower.

        Parameters
        ----------
        time : array_like
            Time (s) at which to calculate the R*A_C value.
        energy : float
            Energy (GeV) of the shower.

        Returns
        -------
        array_like
            The R*A_C value (V*s) at the given time.

        Notes
        -----
        Based on equation 16 of the ARZ paper [1]_. This parameterization
        is only described for electromagnetic showers in the paper. For the
        hadronic shower parameterization see the equivalent hadronic function.

        References
        ----------
        .. [1] J. Alvarez-Muniz et al, "Practical and accurate calculations
            of Askaryan radiation." Physical Review D **84**, 103003 (2011).
            :arxiv:`1106.6283` :doi:`10.1103/PhysRevD.84.103003`

        See Also
        --------
        pyrex.ARZAskaryanSignal.had_shower_RAC : Calculates R*A_C at the given
                                                 time and energy.

        """
        # Get absolute value of time in nanoseconds
        ta = np.abs(time) * 1e9
        rac = np.zeros_like(time)
        rac[time>=0] = (-4.5e-17 * energy *
                        (np.exp(-ta[time>=0]/0.057) + (1+2.87*ta[time>=0])**-3))
        rac[time<0] = (-4.5e-17 * energy *
                       (np.exp(-ta[time<0]/0.030) + (1+3.05*ta[time<0])**-3.5))
        return rac

    @staticmethod
    def had_shower_RAC(time, energy):
        """
        Calculates R*A_C at the given time and energy.

        The R*A_C value is the observation distance R (m) times the vector
        potential (V*s/m) at the Cherenkov angle. This function calculates the
        R*A_C values for an hadronic shower.

        Parameters
        ----------
        time : array_like
            Time (s) at which to calculate the R*A_C value.
        energy : float
            Energy (GeV) of the shower.

        Returns
        -------
        array_like
            The R*A_C value (V*s) at the given time.

        Notes
        -----
        Based on equation 16 of the ARZ paper [1]_, using parameters provided
        by private correspondence with Jaime Alvarez-Muniz, as implemented in
        NuRadioMC and AraSim.

        References
        ----------
        .. [1] J. Alvarez-Muniz et al, "Practical and accurate calculations
            of Askaryan radiation." Physical Review D **84**, 103003 (2011).
            :arxiv:`1106.6283` :doi:`10.1103/PhysRevD.84.103003`

        See Also
        --------
        pyrex.ARZAskaryanSignal.em_shower_RAC : Calculates R*A_C at the given
                                                time and energy.

        """
        # Get absolute value of time in nanoseconds
        ta = np.abs(time) * 1e9
        rac = np.zeros_like(time)
        rac[time>=0] = (-3.2e-17 * energy *
                        (np.exp(-ta[time>=0]/0.065) + (1+3.00*ta[time>=0])**-2.65))
        rac[time<0] = (-3.2e-17 * energy *
                       (np.exp(-ta[time<0]/0.043) + (1+2.92*ta[time<0])**-3.21))
        return rac

    @staticmethod
    def em_shower_profile(z, energy, density=0.92, crit_energy=7.86e-2,
                          rad_length=36.08):
        """
        Calculates the electromagnetic shower longitudinal profile.

        The longitudinal profile is calculated for a given distance, shower
        energy, density, critical energy, and electron radiation length in ice.

        Parameters
        ----------
        z : array_like
            Distance (m) along the shower at which to calculate the charge.
        energy : float
            Energy (GeV) of the shower.
        density : float, optional
            Density (g/cm^3) of ice.
        crit_energy : float, optional
            Critical energy (GeV) for shower formation.
        rad_length : float, optional
            Electron radiation length (g/cm^2) in ice.

        Returns
        -------
        array_like
            The number of particles at the given distance along the shower.

        Notes
        -----
        Profile calculated by the Greisen model [1]_, based on equations 24 and
        25 of the radar feasibility paper [2]_.

        References
        ----------
        .. [1] K. Greisen, "The Extensive Air Showers." Prog. in Cosmic Ray
            Phys. **III**, 1 (1956).
        .. [2] K.D. de Vries et al, "On the feasibility of RADAR detection of
            high-energy neutrino-induced showers in ice." Astropart. Phys.
            **60**, 25-31 (2015). :arxiv:`1312.4331`
            :doi:`10.1016/j.astropartphys.2014.05.009`

        """
        N = np.zeros_like(z)

        # Below critical energy, no shower
        if energy<=crit_energy:
            return N

        # Depth calculated by "integrating" the density along the shower path
        # (in g/cm^2)
        x = 100 * z * density
        x_ratio = x / rad_length
        e_ratio = energy / crit_energy

        # Shower age
        s = 3 * x_ratio / (x_ratio + 2*np.log(e_ratio))

        # Number of particles
        N[z>0] = (0.31 * np.exp(x_ratio[z>0] * (1 - 1.5*np.log(s[z>0])))
                  / np.sqrt(np.log(e_ratio)))

        return N

    @staticmethod
    def had_shower_profile(z, energy, density=0.92, crit_energy=17.006e-2,
                           rad_length=39.562, int_length=113.03,
                           scale_factor=0.11842):
        """
        Calculates the hadronic shower longitudinal profile.

        The longitudinal charge is calculated for a given distance, density,
        critical energy, hadron radiation length, and interaction length in
        ice, plus a scale factor for the number of particles.

        Parameters
        ----------
        z : array_like
            Distance (m) along the shower at which to calculate the charge.
        energy : float
            Energy (GeV) of the shower.
        density : float, optional
            Density (g/cm^3) of ice.
        crit_energy : float, optional
            Critical energy (GeV) for shower formation.
        rad_length : float, optional
            Hadron radiation length (g/cm^2) in ice.
        int_length : float, optional
            Interaction length (g/cm^2) in ice.
        scale_factor : float, optional
            Scale factor S_0 which multiplies the number of particles in the
            shower.

        Returns
        -------
        array_like
            The number of particles at the given distance along the shower.

        Notes
        -----
        Profile calculated by the Gaisser-Hillas model [1]_, based on equation
        1 of the Alvarez hadronic shower paper [2]_.

        References
        ----------
        .. [1] T.K. Gaisser & A.M. Hillas "Reliability of the Method of
            Constant Intensity Cuts for Reconstructing the Average Development
            of Vertical Showers." ICRC proceedings, 353 (1977).
        .. [2] J. Alvarez-Muniz & E. Zas, "EeV Hadronic Showers in Ice: The LPM
            effect." ICRC proceedings, 17-25 (1999). :arxiv:`astro-ph/9906347`

        """
        N = np.zeros_like(z)

        # Below critical energy, no shower
        if energy<=crit_energy:
            return N

        # Calculate shower depth and shower maximum depth in g/cm^2
        x = 100 * z * density
        e_ratio = energy / crit_energy
        x_max = rad_length * np.log(e_ratio)

        # Number of particles
        N[z>0] = (scale_factor * e_ratio * (x_max - int_length) / x_max
                  * (x[z>0] / (x_max - int_length))**(x_max / int_length)
                  * np.exp((x_max - x[z>0])/int_length - 1))

        return N

    @staticmethod
    def max_length(energy, density=0.92, crit_energy=7.86e-2,
                   rad_length=36.08):
        """
        Calculates the depth of a particle shower maximum.

        The shower depth of a shower maximum is calculated for a given density,
        critical energy, and particle radiation length in ice.

        Parameters
        ----------
        energy : float
            Energy (GeV) of the shower.
        density : float, optional
            Density (g/cm^3) of ice.
        crit_energy : float, optional
            Critical energy (GeV) for shower formation.
        rad_length : float, optional
            Radiation length (g/cm^2) in ice of the particle which makes up the
            shower.

        Returns
        -------
        float
            The depth (m) of the shower maximum for a particle shower.

        """
        # Maximum depth in g/cm^2
        x_max = rad_length * np.log(energy / crit_energy) / np.log(2)

        return 0.01 * x_max / density



class ARVZAskaryanSignal(ARZAskaryanSignal):
    """
    Class for generating Askaryan signals according to ARZ parameterization.

    .. deprecated:: 1.10.0
        `ARVZAskaryanSignal` has been renamed `ARZAskaryanSignal`.

    Stores the time-domain information for an Askaryan electric field (V/m)
    produced by the electromagnetic and hadronic showers initiated by a
    neutrino.

    Parameters
    ----------
    times : array_like
        1D array of times (s) for which the signal is defined.
    particle : Particle
        ``Particle`` object responsible for the showers which produce the
        Askaryan signal. Should have an ``energy`` in GeV, ``vertex`` in m,
        and ``id``, plus an ``interaction`` with an ``em_frac`` and
        ``had_frac``.
    viewing_angle : float
        Observation angle (radians) measured relative to the shower axis.
    viewing_distance : float, optional
        Distance (m) between the shower vertex and the observation point (along
        the ray path).
    ice_model : optional
        The ice model to be used for describing the index of refraction of the
        medium.
    t0 : float, optional
        Pulse offset time (s), i.e. time at which the showers take place.

    Attributes
    ----------
    times, values : ndarray
        1D arrays of times (s) and corresponding values which define the signal.
    value_type : Signal.Type.field
        Type of signal, representing the units of the values.
    Type : Enum
        Different value types available for `value_type` of signal objects.
    em_energy : float
        Energy (GeV) of the electromagnetic shower producing the pulse.
    had_energy : float
        Energy (GeV) of the hadronic shower producing the pulse.
    oncone_range : float
        Maximum angular deviation (radians) from the Cherenkov angle which
        should be forced to the Cherenkov angle form factor parameterization.
    vector_potential
    dt
    frequencies
    spectrum
    envelope

    Raises
    ------
    ValueError
        If the `particle` object is not a neutrino or antineutrino with a
        charged-current or neutral-current interaction.

    See Also
    --------
    pyrex.FunctionSignal : Class for signals generated by a function.
    pyrex.Particle : Class for storing particle attributes.

    Notes
    -----
    Calculates the Askaryan signal based on the ARZ parameterization [1]_.
    Uses a Greisen model for the electromagnetic shower profile [2]_, [3]_ and
    a Gaisser-Hillas model for the hadronic shower profile [4]_, [5]_.
    Calculates the electric field from the vector potential using the
    convolution method outlined in section 4 of the ARZ paper, which results
    in the most efficient calculation of the parameterization.

    References
    ----------
    .. [1] J. Alvarez-Muniz et al, "Practical and accurate calculations
        of Askaryan radiation." Physical Review D **84**, 103003 (2011).
        :arxiv:`1106.6283` :doi:`10.1103/PhysRevD.84.103003`
    .. [2] K. Greisen, "The Extensive Air Showers." Prog. in Cosmic Ray Phys.
        **III**, 1 (1956).
    .. [3] K.D. de Vries et al, "On the feasibility of RADAR detection of
        high-energy neutrino-induced showers in ice." Astropart. Phys. **60**,
        25-31 (2015). :arxiv:`1312.4331`
        :doi:`10.1016/j.astropartphys.2014.05.009`
    .. [4] T.K. Gaisser & A.M. Hillas "Reliability of the Method of Constant
        Intensity Cuts for Reconstructing the Average Development of Vertical
        Showers." ICRC proceedings, 353 (1977).
    .. [5] J. Alvarez-Muniz & E. Zas, "EeV Hadronic Showers in Ice: The LPM
        effect." ICRC proceedings, 17-25 (1999). :arxiv:`astro-ph/9906347`

    """
    def __init__(self, times, particle, viewing_angle, viewing_distance=1,
                 ice_model=ice, t0=0):
        warnings.warn("The 'ARVZAskaryanSignal' class has been renamed to "+
                      "'ARZAskaryanSignal', and this name will be removed "+
                      "in a future release", FutureWarning, stacklevel=2)
        super().__init__(times=times, particle=particle,
                         viewing_angle=viewing_angle,
                         viewing_distance=viewing_distance,
                         ice_model=ice_model, t0=t0)



# Set the default Askaryan model
AskaryanSignal = ARZAskaryanSignal