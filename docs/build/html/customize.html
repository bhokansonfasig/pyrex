<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Custom Sub-Package &mdash; PyREx 1.8.0 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="about.html" >
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="PyREx 1.8.0 documentation" href="index.html" >
    <link rel="next" title="Example Code" href="examples.html" >
    <link rel="prev" title="How to Use PyREx" href="usage.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" width="250" alt="PyREx" src="_static/logo_white_transparent.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">PyREx 1.8.0 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="examples.html" title="Example Code"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="usage.html" title="How to Use PyREx"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="custom-sub-package">
<span id="custom-package"></span><h1>Custom Sub-Package<a class="headerlink" href="#custom-sub-package" title="Permalink to this headline">¶</a></h1>
<p>While the PyREx package provides a basis for simulation, the real benefits come in customizing the analysis for different purposes. To this end the custom sub-package allows for plug-in style modules to be distributed for different collaborations.</p>
<p>By default PyREx comes with custom modules for IREX (IceCube Radio Extension) and ARA (Askaryan Radio Array) accessible at <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.irex</span></code> and <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.ara</span></code>, respectively. More information about these modules can be found in their respective sections below.</p>
<p>Other institutions and research groups are encouraged to create their own custom modules to integrate with PyREx. These modules have full access to PyREx as if they were a native part of the package. When PyREx is loaded it automatically scans for these custom modules in certain parts of the filesystem and includes any modules that it can find.
The first place searched is the <code class="docutils literal"><span class="pre">custom</span></code> directory in the PyREx package itself. Next, if a <code class="docutils literal"><span class="pre">.pyrex-custom</span></code> directory exists in the user’s home directory (note the leading <code class="docutils literal"><span class="pre">.</span></code>), its subdirectories are searched for <code class="docutils literal"><span class="pre">custom</span></code> directories and any modules in these directories are included. Finally, if a <code class="docutils literal"><span class="pre">pyrex-custom</span></code> directory exists in the current working directory (this time without the leading <code class="docutils literal"><span class="pre">.</span></code>), its subdirectories are similarly scanned for modules inside <code class="docutils literal"><span class="pre">custom</span></code> directories. Note that if any name-clashing occurs, the first result found takes precedence (without warning). Additionally, none of these <code class="docutils literal"><span class="pre">custom</span></code> directories should contain an <code class="docutils literal"><span class="pre">__init__.py</span></code> file, or else the plug-in system may not work (For more information on the implementation, see PEP 420 and/or David Beazley’s 2015 PyCon talk on Modules and Packages at <a class="reference external" href="https://youtu.be/0oTh1CXRaQ0?t=1h25m45s">https://youtu.be/0oTh1CXRaQ0?t=1h25m45s</a>).</p>
<p>As an example, in the following filesystem layout (which is not meant to reflect the actual current modules available to PyREx) the available custom modules are <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.pyspice</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.irex</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.ara</span></code>, <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.arianna</span></code>, and <code class="xref py py-mod docutils literal"><span class="pre">pyrex.custom.my_analysis</span></code>. Additionally note that the name clash for the ARA module will result in the module included in PyREx being loaded and the ARA module in <code class="docutils literal"><span class="pre">.pyrex-custom</span></code> will be ignored.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/path/to/site-packages/pyrex/
|-- __init__.py
|-- signals.py
|-- antenna.py
|-- ...
|-- custom/
|   |-- pyspice.py
|   |-- irex/
|   |   |-- __init__.py
|   |   |-- antenna.py
|   |   |-- ...
|   |-- ara/
|   |   |-- __init__.py
|   |   |-- antenna.py
|   |   |-- ...

/path/to/home_dir/.pyrex-custom/
|-- ara/
|   |-- custom/
|   |   |-- ara/
|   |   |   |-- __init__.py
|   |   |   |-- antenna.py
|   |   |   |-- ...
|-- arianna/
|   |-- custom/
|   |   |-- arianna/
|   |   |   |-- __init__.py
|   |   |   |-- antenna.py
|   |   |   |-- ...

/path/to/cwd/pyrex-custom/
|-- my_analysis_module/
|   |-- custom/
|   |   |-- my_analysis.py
</pre></div>
</div>
<div class="section" id="ara-custom-module">
<h2>ARA Custom Module<a class="headerlink" href="#ara-custom-module" title="Permalink to this headline">¶</a></h2>
<p>The ARA module contains classes for antennas and detectors as found or proposed for the ARA project.</p>
<p>The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.HpolAntenna.html#pyrex.custom.ara.HpolAntenna" title="pyrex.custom.ara.HpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">HpolAntenna</span></code></a> and <a class="reference internal" href="api/docstrings/pyrex.custom.ara.VpolAntenna.html#pyrex.custom.ara.VpolAntenna" title="pyrex.custom.ara.VpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">VpolAntenna</span></code></a> classes are models of ARA Hpol and Vpol antennas using data lifted from AraSim. They use the antenna directional gains in <code class="docutils literal"><span class="pre">data/ARA_dipoletest1_output_MY_fixed.txt</span></code> and <code class="docutils literal"><span class="pre">data/ARA_bicone6in_output_MY_fixed.txt</span></code> respectively, and the electronics gains in <code class="docutils literal"><span class="pre">data/ARA_Electronics_TotalGain_TwoFilters.txt</span></code>. The trigger condition of these antennas is based on a comparison of the maximum value of the tunnel-diode-convolved waveforms with the rms value of a tunnel-diode-convolved noise waveform.</p>
<p>The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.ARAString.html#pyrex.custom.ara.ARAString" title="pyrex.custom.ara.ARAString"><code class="xref py py-class docutils literal"><span class="pre">ARAString</span></code></a> class creates a string of alternating <a class="reference internal" href="api/docstrings/pyrex.custom.ara.HpolAntenna.html#pyrex.custom.ara.HpolAntenna" title="pyrex.custom.ara.HpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">HpolAntenna</span></code></a> and <a class="reference internal" href="api/docstrings/pyrex.custom.ara.VpolAntenna.html#pyrex.custom.ara.VpolAntenna" title="pyrex.custom.ara.VpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">VpolAntenna</span></code></a> ojbects, as in a typical ARA station. The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.PhasedArrayString.html#pyrex.custom.ara.PhasedArrayString" title="pyrex.custom.ara.PhasedArrayString"><code class="xref py py-class docutils literal"><span class="pre">PhasedArrayString</span></code></a> class implements a more densely-packed string of antennas which trigger based on a threshold trigger on the best beam-formed combination of the antenna waveforms. The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.RegularStation.html#pyrex.custom.ara.RegularStation" title="pyrex.custom.ara.RegularStation"><code class="xref py py-class docutils literal"><span class="pre">RegularStation</span></code></a> class creates a station at the given position with 4 (or another given number) strings spaced evenly around the station center. The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.AlbrechtStation.html#pyrex.custom.ara.AlbrechtStation" title="pyrex.custom.ara.AlbrechtStation"><code class="xref py py-class docutils literal"><span class="pre">AlbrechtStation</span></code></a> class (proposed by Albrecht Karle) creates two phased array strings at the station center, one of <a class="reference internal" href="api/docstrings/pyrex.custom.ara.VpolAntenna.html#pyrex.custom.ara.VpolAntenna" title="pyrex.custom.ara.VpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">VpolAntenna</span></code></a> objects and the other of <a class="reference internal" href="api/docstrings/pyrex.custom.ara.HpolAntenna.html#pyrex.custom.ara.HpolAntenna" title="pyrex.custom.ara.HpolAntenna"><code class="xref py py-class docutils literal"><span class="pre">HpolAntenna</span></code></a> objects, as well as 3 (or another given number) outrigger strings spaced evenly around the station center. The <a class="reference internal" href="api/docstrings/pyrex.custom.ara.HexagonalGrid.html#pyrex.custom.ara.HexagonalGrid" title="pyrex.custom.ara.HexagonalGrid"><code class="xref py py-class docutils literal"><span class="pre">HexagonalGrid</span></code></a> class creates a hexagonal grid of stations, spiralling outward from the center.</p>
</div>
<div class="section" id="arianna-custom-module">
<h2>ARIANNA Custom Module<a class="headerlink" href="#arianna-custom-module" title="Permalink to this headline">¶</a></h2>
<p>The ARIANNA module contains classes for antennas as found in the ARIANNA project.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">LPDA</span></code> class is the model of the ARIANNA LPDA antenna based on data from NuRadioReco. It uses directional/polarization gain from <code class="docutils literal"><span class="pre">data/createLPDA_100MHz_InfFirn.ad1</span></code> and <code class="docutils literal"><span class="pre">data/createLPDA_100MHz_InfFirn.ra1</span></code>, and amplification gain from <code class="docutils literal"><span class="pre">data/amp_300_gain.csv</span></code> and <code class="docutils literal"><span class="pre">data/amp_300_phase.csv</span></code>. The trigger condition of the antenna requires the signal to reach above and below some threshold values within a trigger window.</p>
</div>
<div class="section" id="irex-custom-module">
<h2>IREX Custom Module<a class="headerlink" href="#irex-custom-module" title="Permalink to this headline">¶</a></h2>
<p>The IREX module contains classes for antennas and detectors which use waveform envelopes rather than raw waveforms. The detectors provided allow for testing of grid and station geometries.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">EvelopeHpol</span></code> and <code class="xref py py-class docutils literal"><span class="pre">EvelopeVpol</span></code> classes wrap models of ARA Hpol and Vpol antennas with an additional front-end which uses a diode-bridge circuit to create waveform envelopes. The trigger condition for these antennas is a simple threshold trigger on the envelopes.</p>
<p>The <code class="xref py py-class docutils literal"><span class="pre">IREXString</span></code> class creates a string of <code class="xref py py-class docutils literal"><span class="pre">EvelopeVpol</span></code> antennas at a given position. The <code class="xref py py-class docutils literal"><span class="pre">RegularStation</span></code> class creates a station at a given position with 4 (or another given number) strings spaced evenly around the station center. The <code class="xref py py-class docutils literal"><span class="pre">CoxeterStation</span></code> class creates a station at a given position similar to the <code class="xref py py-class docutils literal"><span class="pre">RegularStation</span></code>, but with one string at the station center and the rest spaced evenly around the center. The <code class="xref py py-class docutils literal"><span class="pre">StationGrid</span></code> class creates a rectangular grid of stations (or strings, as specified by the station type). The dimensions of the grid in stations is Nx by Ny where N is the total number of stations, Nx=floor(sqrt(N)), and Ny=floor(N/Nx).</p>
</div>
<div class="section" id="build-your-own-custom-module">
<h2>Build Your Own Custom Module<a class="headerlink" href="#build-your-own-custom-module" title="Permalink to this headline">¶</a></h2>
<p>In the course of using PyREx you may wish to change some behavior of parts of the code. Due to the modularity of the code, many behavoirs should be customizable by substituting in your own classes inheriting from those already in PyREx. By adding these classes to your own custom module, your code can behave as though it was a native part of the PyREx package. Below the classes which can be easily substituted with your own version are listed, and descriptions of the behavior expected of the classes is outlined.</p>
<div class="section" id="askaryan-signal">
<h3>Askaryan Signal<a class="headerlink" href="#askaryan-signal" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.AskaryanSignal.html#pyrex.AskaryanSignal" title="pyrex.AskaryanSignal"><code class="xref py py-class docutils literal"><span class="pre">AskaryanSignal</span></code></a> class is responsible for storing the time-domain signal of the Askaryan signal produced by a particle shower. The <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method of an <a class="reference internal" href="docstrings/pyrex.AskaryanSignal.html#pyrex.AskaryanSignal" title="pyrex.AskaryanSignal"><code class="xref py py-class docutils literal"><span class="pre">AskaryanSignal</span></code></a>-like class must accept the arguments listed below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">times</span></code></td>
<td>A list-type (usually a numpy array) of time values at which to calculate the amplitude of the Askaryan pulse.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">particle</span></code></td>
<td>A <code class="docutils literal"><span class="pre">Particle</span></code> object representing the neutrino that causes the event. Should have an <code class="docutils literal"><span class="pre">energy</span></code>, <code class="docutils literal"><span class="pre">vertex</span></code>, <code class="docutils literal"><span class="pre">id</span></code>, and an <code class="docutils literal"><span class="pre">interaction</span></code> with an <code class="docutils literal"><span class="pre">em_frac</span></code> and <code class="docutils literal"><span class="pre">had_frac</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">viewing_angle</span></code></td>
<td>The viewing angle in radians measured from the shower axis.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">viewing_distance</span></code></td>
<td>The distance of the observation point from the shower vertex.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ice</span></code></td>
<td>The ice model to be used for describing the medium’s index of refraction.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">t0</span></code></td>
<td>The starting time of the Askaryan pulse / showers (default 0).</td>
</tr>
</tbody>
</table>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method should result in a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object with <code class="xref py py-attr docutils literal"><span class="pre">values</span></code> being a numpy array of amplitudes corresponding to the given <code class="xref py py-attr docutils literal"><span class="pre">times</span></code> and should have a proper <code class="xref py py-attr docutils literal"><span class="pre">value_type</span></code>. Additionally, all methods of the <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> class should be implemented (typically by just inheriting from <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a>).</p>
</div>
<div class="section" id="antenna-antenna-system">
<h3>Antenna / Antenna System<a class="headerlink" href="#antenna-antenna-system" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal"><span class="pre">Antenna</span></code></a> class is primarily responsible for receiving and triggering on <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> objects. The <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method of an <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal"><span class="pre">Antenna</span></code></a>-like class must accept a <code class="docutils literal"><span class="pre">position</span></code> argument, and any other arguments may be specified as desired. The <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method should set the <code class="xref py py-attr docutils literal"><span class="pre">position</span></code> attribute to the given argument. If not inheriting from <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal"><span class="pre">Antenna</span></code></a>, the following methods and attributes must be implemented and may require the <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method to set some other attributes. <a class="reference internal" href="docstrings/pyrex.AntennaSystem.html#pyrex.AntennaSystem" title="pyrex.AntennaSystem"><code class="xref py py-class docutils literal"><span class="pre">AntennaSystem</span></code></a>-like classes must expose the same required methods and attributes as <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal"><span class="pre">Antenna</span></code></a>-like classes, typically by passing calls down to an underlying <a class="reference internal" href="docstrings/pyrex.Antenna.html#pyrex.Antenna" title="pyrex.Antenna"><code class="xref py py-class docutils literal"><span class="pre">Antenna</span></code></a>-like object and applying some extra processing.</p>
<p>The <a class="reference internal" href="api/signals.html#module-pyrex.signals" title="pyrex.signals"><code class="xref py py-attr docutils literal"><span class="pre">signals</span></code></a> attribute should contain a list of all pure <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> objects that the antenna has seen. This is different from the <code class="xref py py-attr docutils literal"><span class="pre">all_waveforms</span></code> attribute, which should contain a list of all waveform (pure signal + noise) <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> objects the antenna has seen. Yet again different from the <code class="xref py py-attr docutils literal"><span class="pre">waveforms</span></code> attribute, which should contain only those waveforms which have triggered the antenna.</p>
<p>If using the default <code class="xref py py-attr docutils literal"><span class="pre">all_waveforms</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">waveforms</span></code>, a <code class="xref py py-attr docutils literal"><span class="pre">_noises</span></code> attribute and <code class="xref py py-attr docutils literal"><span class="pre">_triggers</span></code> attribute must be initialized to empty lists in <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code>. Additionally a <code class="xref py py-meth docutils literal"><span class="pre">make_noise()</span></code> method must be defined which takes a <code class="docutils literal"><span class="pre">times</span></code> array and returns a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object with noise amplitudes in the <code class="xref py py-attr docutils literal"><span class="pre">values</span></code> attribute. If using the default <code class="xref py py-meth docutils literal"><span class="pre">make_noise()</span></code> method, a <code class="xref py py-attr docutils literal"><span class="pre">_noise_master</span></code> attribute must be set in <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> to either <code class="docutils literal"><span class="pre">None</span></code> or a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object that can generate noise waveforms (setting <code class="xref py py-attr docutils literal"><span class="pre">_noise_master</span></code> to <code class="docutils literal"><span class="pre">None</span></code> and handling noise generation with the attributes <code class="xref py py-attr docutils literal"><span class="pre">freq_range</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">noise_rms</span></code>, or <code class="xref py py-attr docutils literal"><span class="pre">temperature</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">resistance</span></code>, is recommended).</p>
<p>A <code class="xref py py-meth docutils literal"><span class="pre">full_waveform()</span></code> method is required which will take a <code class="docutils literal"><span class="pre">times</span></code> array and return a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object of the waveform the antenna sees at those times. If using the default <code class="xref py py-meth docutils literal"><span class="pre">full_waveform()</span></code>, a <code class="xref py py-attr docutils literal"><span class="pre">noisy</span></code> attribute is required which contains a boolean value of whether or not the antenna includes noise in its waveforms. If <code class="xref py py-attr docutils literal"><span class="pre">noisy</span></code> is <code class="docutils literal"><span class="pre">True</span></code> then a <code class="xref py py-meth docutils literal"><span class="pre">make_noise()</span></code> method is also required, as described in the previous paragraph.</p>
<p>An <code class="xref py py-attr docutils literal"><span class="pre">is_hit</span></code> attribute is required which will be a boolean of whether or not the antenna has been triggered by any waveforms. Similarly an <code class="xref py py-meth docutils literal"><span class="pre">is_hit_during()</span></code> method is required which will take a <code class="docutils literal"><span class="pre">times</span></code> array and return a boolean of whether the antenna is triggered during those times.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">trigger()</span></code> method of the antenna should take a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object and return a boolean of whether or not that signal would trigger the antenna.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> method should reset the antenna to a state of having received no signals (i.e. the state just after initialization), and should accept a boolean for <code class="docutils literal"><span class="pre">reset_noise</span></code> which will force the noise waveforms to be recalculated. If using the default <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> method, the <code class="xref py py-attr docutils literal"><span class="pre">_noises</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">_triggers</span></code> attributes must be lists.</p>
<p>A <code class="xref py py-meth docutils literal"><span class="pre">receive()</span></code> method is required which will take a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object as <code class="docutils literal"><span class="pre">signal</span></code>, a 3-vector (list) as <code class="docutils literal"><span class="pre">direction</span></code>, and a 3-vector (list) as <code class="docutils literal"><span class="pre">polarization</span></code>. This function doesn’t return anything, but instead processes the input signal and stores it to the <a class="reference internal" href="api/signals.html#module-pyrex.signals" title="pyrex.signals"><code class="xref py py-attr docutils literal"><span class="pre">signals</span></code></a> list (and anything else needed for the antenna to have officially received the signal). This is the final required method, but if using the default <code class="xref py py-meth docutils literal"><span class="pre">receive()</span></code> method, an <code class="xref py py-attr docutils literal"><span class="pre">antenna_factor</span></code> attribute is needed to define the conversion from electric field to voltage and an <code class="xref py py-attr docutils literal"><span class="pre">efficiency</span></code> attribute is required, along with four more methods which must be defined:</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">_convert_to_antenna_coordinates()</span></code> method should take a point in cartesian coordinates and return the <code class="docutils literal"><span class="pre">r</span></code>, <code class="docutils literal"><span class="pre">theta</span></code>, and <code class="docutils literal"><span class="pre">phi</span></code> values of that point relative to the antenna. The <code class="xref py py-meth docutils literal"><span class="pre">directional_gain()</span></code> method should take <code class="docutils literal"><span class="pre">theta</span></code> and <code class="docutils literal"><span class="pre">phi</span></code> in radians and return a (complex) gain based on the directional response of the antenna. Similarly the <code class="xref py py-meth docutils literal"><span class="pre">polarization_gain()</span></code> method should take a <code class="docutils literal"><span class="pre">polarization</span></code> 3-vector (list) of an incoming signal and return a (complex) gain based on the polarization response of the antenna. Finally, the <code class="xref py py-meth docutils literal"><span class="pre">response()</span></code> method should take a list of frequencies and return the (complex) gains of the frequency response of the antenna. This assumes that the directional and frequency responses are separable. If this is not the case then the gains may be better handled with a custom <code class="xref py py-meth docutils literal"><span class="pre">receive()</span></code> method.</p>
</div>
<div class="section" id="detector">
<h3>Detector<a class="headerlink" href="#detector" title="Permalink to this headline">¶</a></h3>
<p>The preferred method of creating your own detector class is to inherit from the <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal"><span class="pre">Detector</span></code></a> class and then implement the <code class="xref py py-meth docutils literal"><span class="pre">set_positions()</span></code> method, the <code class="xref py py-meth docutils literal"><span class="pre">triggered()</span></code> method, and potentially the <code class="xref py py-meth docutils literal"><span class="pre">build_antennas()</span></code> method. However the only requirement of a <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal"><span class="pre">Detector</span></code></a>-like object is that iterating over it will visit each antenna exactly once. This means that a simple list of antennas is an acceptable rudimentary detector. The advantages of using the <a class="reference internal" href="docstrings/pyrex.Detector.html#pyrex.Detector" title="pyrex.Detector"><code class="xref py py-class docutils literal"><span class="pre">Detector</span></code></a> class are easy breaking into subsets (a detector could be made up of stations, which in turn are made up of strings) and the simpler <code class="xref py py-meth docutils literal"><span class="pre">triggered()</span></code> method for trigger checks.</p>
</div>
<div class="section" id="ice-model">
<h3>Ice Model<a class="headerlink" href="#ice-model" title="Permalink to this headline">¶</a></h3>
<p>Ice model classes are responsible for describing the properties of the ice as functions of depth and frequency. While not explicitly required, all ice model classes in PyREx are defined only with static and class methods, so no <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method is actually necessary. The necessary methods, however, are as follows:</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">index()</span></code> method should take a depth (or numpy array of depths) and return the corresponding index of refraction. Conversely, the <code class="xref py py-meth docutils literal"><span class="pre">depth_with_index()</span></code> method should take an index of refraction (or numpy array of indices) and return othe corresponding depths. In the case of degeneracy here (for example with uniform ice), the recommended behavior is to return the shallowest depth with the given index, though PyREx’s behavior in cases of non-monotonic index functions is not well defined.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">temperature()</span></code> method should take a depth (or numpy array of depths) and return the corresponding ice temperature in Kelvin.</p>
<p>Finally, the <code class="xref py py-meth docutils literal"><span class="pre">attenuation_length()</span></code> function should take a depth (or numpy array of depths) and a frequency (or numpy array of frequencies) and return the corresponding attenuation length. In the case of one scalar and one array argument, a simple 1D array should be returned. In the case of both arguments being arrays, the return value should be a 2D array where each row represents different frequencies at a single depth and each column represents different depths at a single frequency.</p>
</div>
<div class="section" id="ray-tracer-ray-trace-path">
<h3>Ray Tracer / Ray Trace Path<a class="headerlink" href="#ray-tracer-ray-trace-path" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal"><span class="pre">RayTracer</span></code></a> and <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal"><span class="pre">RayTracePath</span></code></a> classes are responsible for handling ray tracing through the ice between shower vertices and antenna positions. The <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal"><span class="pre">RayTracer</span></code></a> class finds the paths between the two points and the <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal"><span class="pre">RayTracePath</span></code></a> calculates values along the path. Due to the potential for high calculation costs, the PyREx <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal"><span class="pre">RayTracer</span></code></a> and <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal"><span class="pre">RayTracePath</span></code></a> classess inherit from a <code class="xref py py-class docutils literal"><span class="pre">LazyMutableClass</span></code> which allows the use of a <code class="xref py py-func docutils literal"><span class="pre">lazy_property()</span></code> decorator to cache results of attribute calculations. It is recommended that any other ray tracing classes consider doing this as well.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method of a <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal"><span class="pre">RayTracer</span></code></a>-like class should take as arguments a 3-vector (list) <code class="docutils literal"><span class="pre">from_point</span></code>, a 3-vector (list) <code class="docutils literal"><span class="pre">to_point</span></code>, and an <a class="reference internal" href="docstrings/pyrex.IceModel.html#pyrex.IceModel" title="pyrex.IceModel"><code class="xref py py-class docutils literal"><span class="pre">IceModel</span></code></a>-like <code class="docutils literal"><span class="pre">ice_model</span></code>. The only required features of the class are a boolean attribute <code class="xref py py-attr docutils literal"><span class="pre">exists</span></code> recording whether or not paths exist between the given points, and an iterable attribute <code class="xref py py-attr docutils literal"><span class="pre">solutions</span></code> which iterates over <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal"><span class="pre">RayTracePath</span></code></a>-like objects between the points.</p>
<p>A <a class="reference internal" href="docstrings/pyrex.RayTracePath.html#pyrex.RayTracePath" title="pyrex.RayTracePath"><code class="xref py py-class docutils literal"><span class="pre">RayTracePath</span></code></a>-like class will be initialized by a corresponding <a class="reference internal" href="docstrings/pyrex.RayTracer.html#pyrex.RayTracer" title="pyrex.RayTracer"><code class="xref py py-class docutils literal"><span class="pre">RayTracer</span></code></a>-like object, so there are no requirements on its <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method. The path must have <code class="xref py py-attr docutils literal"><span class="pre">emitted_direction</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">received_direction</span></code> attributes which are numpy arrays of the cartesian direction the ray is pointing at the <code class="xref py py-attr docutils literal"><span class="pre">from_point</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">to_point</span></code> of the ray tracer, respectively. The path must also have attributes for the <code class="xref py py-attr docutils literal"><span class="pre">path_length</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">tof</span></code> (time of flight) alon the path.</p>
<p>The path class must have a <code class="xref py py-meth docutils literal"><span class="pre">propagate()</span></code> method which takes a <a class="reference internal" href="docstrings/pyrex.Signal.html#pyrex.Signal" title="pyrex.Signal"><code class="xref py py-class docutils literal"><span class="pre">Signal</span></code></a> object as its argument and propagates that signal by applying any attenuation and time of flight. This method does not have a return value. Additionally, note that any 1/R factor that the signal could have is not applied in this method, but externally by dividing the singal values by the <code class="xref py py-attr docutils literal"><span class="pre">path_length</span></code>. If using the default <code class="xref py py-meth docutils literal"><span class="pre">propagate()</span></code> method, an <code class="xref py py-meth docutils literal"><span class="pre">attenuation()</span></code> method is required which takes an array of frequencies <code class="docutils literal"><span class="pre">f</span></code> and returns the attenuation factors for a signal along the path at those frequencies.</p>
<p>Finally, though not required it is recommended that the path have a <code class="xref py py-attr docutils literal"><span class="pre">coordinates</span></code> attribute which is a list of lists of the x, y, and z coordinates along the path (with some reasonable step size). This method is used for plotting purposes and does not need to have the accuracy necessary for calculations.</p>
</div>
<div class="section" id="interaction-model">
<h3>Interaction Model<a class="headerlink" href="#interaction-model" title="Permalink to this headline">¶</a></h3>
<p>The interaction model used for <a class="reference internal" href="docstrings/pyrex.Particle.html#pyrex.Particle" title="pyrex.Particle"><code class="xref py py-class docutils literal"><span class="pre">Particle</span></code></a> interactions in ice handles the cross sections and interaction lengths of neutrinos, as well as the ratios of their interaction types and the resulting shower fractions. An interaction class should inherit from <code class="xref py py-class docutils literal"><span class="pre">Interaction</span></code> (preferrably keeping its <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code> method) and should implement the following methods:</p>
<p>The <code class="xref py py-attr docutils literal"><span class="pre">cross_section</span></code> property method should return the neutrino cross section for the <code class="xref py py-attr docutils literal"><span class="pre">Interaction.particle</span></code> parent, specific to the <code class="xref py py-attr docutils literal"><span class="pre">Interaction.kind</span></code>. Similarly the <code class="xref py py-attr docutils literal"><span class="pre">total_cross_section</span></code> property method should return the neutrino cross section for the <code class="xref py py-attr docutils literal"><span class="pre">Interaction.particle</span></code> parent, but this should be the total cross section for both charged-current and neutral-current interactions. The <code class="xref py py-attr docutils literal"><span class="pre">interaction_length</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">total_interaction_length</span></code> properties will convert these cross sections to interaction lengths automatically.</p>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">choose_interaction()</span></code> method should return a value from <code class="xref py py-class docutils literal"><span class="pre">Interaction.Type</span></code> representing the interaction type based on a random choice. Similarly the <code class="xref py py-meth docutils literal"><span class="pre">choose_inelasticity()</span></code> method should return an inelasticity value based on a random choice, and the <code class="xref py py-meth docutils literal"><span class="pre">choose_shower_fractions()</span></code> method return calculate electromagnetic and hadronic fractions based on the <code class="xref py py-attr docutils literal"><span class="pre">inelasticity</span></code> attribute storing the inelasticity value from <code class="xref py py-meth docutils literal"><span class="pre">choose_inelasticity()</span></code>. The <code class="xref py py-meth docutils literal"><span class="pre">choose_shower_fractions()</span></code> can be either chosen based on random processes like secondary generation or deterministic.</p>
</div>
<div class="section" id="particle-generator">
<h3>Particle Generator<a class="headerlink" href="#particle-generator" title="Permalink to this headline">¶</a></h3>
<p>The particle generator classes are quite flexible. The only requirement is that they possess an <code class="xref py py-meth docutils literal"><span class="pre">create_event()</span></code> method which returns a <a class="reference internal" href="docstrings/pyrex.Event.html#pyrex.Event" title="pyrex.Event"><code class="xref py py-class docutils literal"><span class="pre">Event</span></code></a> object consisting of at least one <a class="reference internal" href="docstrings/pyrex.Particle.html#pyrex.Particle" title="pyrex.Particle"><code class="xref py py-class docutils literal"><span class="pre">Particle</span></code></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyREx</a></h1>



<p class="blurb">A Python package for simulation of neutrinos and radio antennas in ice.
Version 1.8.0</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=bhokansonfasig&repo=pyrex&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<div id="searchbox" style="display: none" role="search">
<h3>Quick search</h3>
  <div class="searchformwrapper">
  <form class="search" action="search.html" method="get">
    <input type="text" name="q" />
    <input type="submit" value="Go" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About PyREx</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">How to Use PyREx</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom Sub-Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ara-custom-module">ARA Custom Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arianna-custom-module">ARIANNA Custom Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#irex-custom-module">IREX Custom Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#build-your-own-custom-module">Build Your Own Custom Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to PyREx</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">PyREx API</a></li>
<li class="toctree-l1"><a class="reference internal" href="versions.html">Version History</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://github.com/bhokansonfasig/pyrex">Source (GitHub)</a></li>
    
    <li class="toctree-l1"><a href="https://github.com/bhokansonfasig/pyrex/issues">Report an Issue</a></li>
    
</ul>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018, Benjamin Hokanson-Fasig.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.6.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>